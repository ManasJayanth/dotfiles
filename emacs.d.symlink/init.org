#+TITLE init.org
* Compile init.el

I'm using org-mode to structure my configuration. Inspired by [[https://github.com/sachac/.emacs.d][Sacha Chua]] and
[[https://github.com/eschulte/emacs24-starter-kit/][Emacs Starter Kit]].

* Initialise

** Profiling
#+BEGIN_SRC emacs-lisp
(defconst md/emacs-init-start (current-time))
#+END_SRC

** Init performance optimising

This wraps the rest of the file.

- Increase the GC threshold to 100MB. This decreases Emacs load time by approx
  600ms when not using ~use-package~. With ~use-package~, it still decreases load
  time by 250ms.

- The default file-handler-name-alist contains some regexps that are run against
  every .el/.elc loaded on startup. Preventing this apparently decreases load
  time, although I haven't noticed much.

#+BEGIN_SRC emacs-lisp
  (let ((file-handler-name-alist nil)
         (gc-cons-threshold 100000000))
#+END_SRC

** Dotfiles

I use this to refer to this directory / file:

#+BEGIN_SRC emacs-lisp
  (defun md/dotfiles-get-root ()
    (or
      (getenv "DOTFILES")
      (concat (expand-file-name "~") "/dotfiles")))

  (defun md/dotfiles-get-path (path)
    (concat (md/dotfiles-get-root) "/" path))
#+END_SRC

** Emacs Package setup
#+BEGIN_SRC emacs-lisp
    (package-initialize)

    (setq package-archives
          '(("gnu" . "http://elpa.gnu.org/packages/")
            ("marmalade" . "http://marmalade-repo.org/packages/")
            ("melpa" . "http://melpa.milkbox.net/packages/")
            ("org" . "http://orgmode.org/elpa/")))

    (setq load-prefer-newer t)  ; new in v24.4
#+END_SRC

** Custom file

#+BEGIN_SRC emacs-lisp
(setq custom-file (md/dotfiles-get-path "emacs.d.symlink/custom.el"))
(load custom-file 'noerror)
#+END_SRC

** use-package setup

If ~use-package~ isn't installed, I should install it.

#+BEGIN_SRC emacs-lisp
(setq use-package-always-ensure nil
      use-package-verbose t
      use-package-minimum-reported-time 0.01)

(eval-when-compile
    (require 'use-package))

(require 'bind-key)  ; Required for :bind in use-package
#+END_SRC

** exec-path-from-shell
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
   :if (memq window-system '(mac ns))
   :demand t
   :config
   (progn (exec-path-from-shell-initialize)))
#+END_SRC
* Sane Emacs behaviour

These are mostly to get the base appearance / behaviour of Emacs close to
what I'm used to from vim.

** Leader map(s)
I was using evil-leader, but think I can get the functionality I care about just
by using a keymap:

Use ~md/leader-map~ for my general-purpose leader. Mode-specific leader maps
inherit from the ~md/leader-map~.

#+BEGIN_SRC emacs-lisp
  (defvar md/leader-map (make-sparse-keymap))

  (defvar md/python-mode-leader-map (make-sparse-keymap))
  (set-keymap-parent md/python-mode-leader-map md/leader-map)

  (defvar md/go-mode-leader-map (make-sparse-keymap))
  (set-keymap-parent md/go-mode-leader-map md/leader-map)

  (defvar md/scheme-mode-leader-map (make-sparse-keymap))
  (set-keymap-parent md/scheme-mode-leader-map md/leader-map)
#+END_SRC

** Splash screen
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t)
#+END_SRC
** Fill column
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)

(use-package fill-column-indicator
 :defer 1
 :config
 (progn
   ;; Width of the fill column rule
   (setq fci-rule-width 5)))
#+END_SRC

** Menu bar

The toolbar appears in the GUI frame. I don't want it:

#+BEGIN_SRC emacs-lisp
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
#+END_SRC

The menu bar is intrusive in terminal Emacs, so disable it. On the OS X app it
appears as any other app toolbar at the top of the screen, which is fine:

#+BEGIN_SRC emacs-lisp
  (when (not (display-graphic-p))
    (menu-bar-mode -1))
#+END_SRC

** Fontify
Some things don't fontify quick enough (eg. fic-mode). This helps to contain
that issue:

#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook 'font-lock-fontify-buffer)
#+END_SRC

** Text wrapping

Auto-wrap text.

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'prog-mode-hook 'turn-on-auto-fill)
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
#+END_SRC

** Linum / line numbers in left margin

By default, in terminal Emacs the linum margin terminates right against the
first column of the buffer. This copies the code from linum's =dynamic=
linum-format, but adds a space so there is some separation:

#+BEGIN_SRC emacs-lisp
(setq linum-format
      (lambda (line-number)
        (let ((w (length (number-to-string
                          (count-lines (point-min) (point-max))))))
          (propertize
           (format
            (concat "%" (number-to-string w) "d ")
            line-number) 'face 'linum))))

;; TODO - I thought use-package would defer the loading of this until I do "ln",
;; but "ln" doesn't work.
(use-package linum
  :defer 1
  :bind (:map md/leader-map
         ("tn" . linum-mode)))
#+END_SRC

** Highlight cursor line
#+BEGIN_SRC emacs-lisp
;; Disable this for a minute
;;(global-hl-line-mode 1)
#+END_SRC

** Default font
#+BEGIN_SRC emacs-lisp
(defun md/set-default-font ()
  (interactive)
  (if (string= system-name "mattmbp.local")
      (set-frame-font "Monaco-12:antialias=subpixel")
    (set-frame-font "Monaco-13:antialias=subpixel")))

(md/set-default-font)
#+END_SRC

When using a server with both GUI and terminal clients attached, I want them to
show their terminal/GUI-specific default fonts:

#+BEGIN_SRC emacs-lisp
(add-hook 'focus-in-hook 'md/set-default-font)
#+END_SRC

** Scroll behaviour
#+BEGIN_SRC emacs-lisp
(setq

  ;; Start scrolling when the cursor is one line away from the top/bottom.
  scroll-margin 1

  ;; If at the bottom of the file, don't allow scroll beyond that (because
  ;; there's no use in having half a screen of empty space
  scroll-conservatively 999

  ;; Only scroll one row at a time. Default behaviour is to centre the row.
  scroll-step 1)

;; Remove scrollbars (GUI only) to get extra screen space
(use-package scroll-bar
  :if (display-graphic-p)
  :demand t
  :config (scroll-bar-mode -1))
#+END_SRC

** Cursor blinking

Ensure cursor isn't blinking:
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
#+END_SRC

** Fringe
NOTE: The Fringe only displays in GUI Emacs.

#+BEGIN_SRC emacs-lisp
(defun md/fringe-mode ()
  (interactive)
  ;; Create fringe at left side of screen.
  ;; I think 8 is the minimum width needed to display flycheck markers properly.
  (fringe-mode '(8 . 0)))

;; I just want to use this for flycheck mode.
(add-hook 'prog-mode-hook 'md/fringe-mode)

#+END_SRC

** Indentation
#+BEGIN_SRC emacs-lisp
  (setq-default

   ;; Use spaces instead of tabs
   indent-tabs-mode nil

   ;; Display tab as 4 chars wide
   tab-width 4)

  ;; Emable on-the-fly indenting. TODO - read docs for this
  (electric-indent-mode 1)
#+END_SRC
** Disable the bell
#+BEGIN_SRC emacs-lisp
(setq visible-bell nil
      ring-bell-function 'ignore)
#+END_SRC

** Terminal colour fixes

Emacs can use bold fonts, but iTerm is set to display bold fonts as "bright"
colours (which is necessary to support the Solarized 16-colour palette). This
means iTerm interprets the bold Emacs colours as bright and changes their
colour (eg. from yellow to grey), which I don't want.

I'm not sure why I didn't run into this issue with vim, and this is surely not
the right fix, but it works for now:

#+BEGIN_SRC emacs-lisp
  (when (not (display-graphic-p))
    (mapc
     (lambda (face)
       ;; Same issue with underline too.
       (set-face-underline face nil (selected-frame))

       (set-face-bold face nil (selected-frame)))
     (face-list)))
#+END_SRC

** Terminal clipboard fixes

Terminal Emacs doesn't integrate with the system clipboard by default. ~xclip~
provides this behaviour in the same way that GUI Emacs has it.

#+BEGIN_SRC emacs-lisp
  (use-package xclip
    :if (not (display-graphic-p))
    :defer 1
    :config
    (progn
      (turn-on-xclip)))
#+END_SRC

** Message buffer

Increase the number of messages:

#+BEGIN_SRC emacs-lisp
(setq message-log-max 10000)
#+END_SRC
** Modifier keys
*** OS X

- GUI

	- LEFT ALT :: nil (ie. standard alt/option behaviour)
  - LEFT CMD :: Meta
	- RIGHT CMD :: Super (ie. standard cmd behaviour in GUI emacs)
	- RIGHT ALT :: nil (ie. standard alt/option behaviour)

- iTerm2

	- LEFT ALT :: nil (ie. standard alt/option behaviour)
  - LEFT CMD :: iTerm cmd key (so can do usual shortcuts eg. cmd-tab)
	- RIGHT CMD :: Meta
	- RIGHT ALT :: nil (ie. standard alt/option behaviour)

	- I use the right cmd key as Meta in the terminal:

    - Under the "keys" tab, set "right cmd" to send "right option", and
      "right option" to send "left option".

    - Under the "profiles" tab, set "Right option key acts as +Esc".

#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'darwin)
      (setq

       ;; Set alt/option to use its default behaviour in OS X , so I can do
       ;; eg. alt+3 to insert #. By default in Emacs this is Meta, but I find Meta more
       ;; accessible on the left cmd key.
       ns-option-modifier nil

       ;; This is the default, and seems to handle the standard cmd key
       ;; bindings, so apple cmd+c runs super+c in emacs, etc. I don't use them
       ;; much, but they might be useful sometimes.
       ns-right-command-modifier 'super

       ;; Instead of the cmd bindings (that I don't use much), use the left
       ;; cmd key for Meta bindings. This is easier to reach than the default Meta
       ;; key (which is alt).
       ns-command-modifier 'meta))
#+END_SRC
** Backups
#+BEGIN_SRC emacs-lisp
;; Backup everything to the same directory, rather than dropping
;; files all over the place
(setq backup-directory-alist
      `(("." . ,(md/dotfiles-get-path "emacs.d.symlink/.backups"))))
#+END_SRC
* Misc utils
** Odd functions

#+BEGIN_SRC emacs-lisp
  (defun md/strip-whitespace-and-save ()
    (interactive)
    (delete-trailing-whitespace)
    (save-buffer))

  (defun md/fontify-buffer ()
    "Fontify the buffer and tell me it happened."
    (interactive)
    (font-lock-fontify-buffer)
    (message "Fontified buffer"))

  (defun md/file-info ()
    (interactive)
    (message
     "%s | %s lines | %3d%% | %s"
             (buffer-file-name)
             (count-lines (point-min) (point-max))
             (/ (window-end) 0.01 (point-max))
             major-mode))

  (defun md/mode-info ()
    (interactive)
    (message
     (format
      "%s"
      (with-temp-buffer
        (let (mm result)
          (dolist (mm (sort minor-mode-list 'string<) result)
            (insert (format "%s\n" mm))
            (setq result (buffer-substring (point-min) (point-max))))
          result)))))

  (defun md/switch-to-buffer-scratch ()
    (interactive)
    (switch-to-buffer "*scratch*"))
#+END_SRC


It's a shame that "unfill" functions aren't included by default, but they're
easy enough to implement:

#+BEGIN_SRC emacs-lisp
  (defun md/unfill-paragraph ()
    "Because I can't always wrap to 80 characters :("
    (interactive)
    (let ((fill-column most-positive-fixnum))
      (fill-paragraph)))

  (defun md/unfill-region (start end)
    (interactive "r")
    (let ((fill-column most-positive-fixnum))
      (fill-region start end)))
#+END_SRC

** Bindings
I seem to use =describe-face= a lot:
#+BEGIN_SRC emacs-lisp
(bind-key "x" 'describe-face help-map)
(bind-key "C-k" 'describe-personal-keybindings help-map)
#+END_SRC
** Settings
#+BEGIN_SRC emacs-lisp
  (setq debug-on-error nil)
  (setq delete-by-moving-to-trash t)
#+END_SRC
* Evil
** Base evil

- Note on md/evil-fill and unfill:

  - Ideally, I would have a binding that maps to fill / unfill /paragraphs/ in
    normal mode, but /regions/ in visual mode. Currently I'm not sure how to get
    Evil to create different md/leader-map bindings for different Evil states,
    so for now I'll just use this workaround of checking the state in the
    function:

#+BEGIN_SRC emacs-lisp
  (use-package evil
   :demand t
   :config
   (progn
     (defun md/normal-state-and-save ()
       (interactive)
       (evil-normal-state)
       (save-buffer))

     (defun md/insert-blank-line-before ()
       (interactive)
       (save-excursion
         (end-of-line)
         (open-line 1)
         (save-buffer)))

     (defun md/insert-blank-line-after ()
       (interactive)
       (save-excursion
         (evil-previous-visual-line)
         (end-of-line)
         (open-line 1)
         (save-buffer)))

     (defun md/evil-fill (&optional start end)
       (interactive
        (if (use-region-p)
            (list (region-beginning) (region-end))
          (list nil nil)))
       (if (string= evil-state "visual")
           (fill-region start end)
         (fill-paragraph)))

     (defun md/evil-unfill (&optional start end)
       (interactive
        (if (use-region-p)
            (list (region-beginning) (region-end))
          (list nil nil)))
       (if (string= evil-state "visual")
           (md/unfill-region start end)
         (md/unfill-paragraph)))

     ;; Can't work out how to properly define map bindings using ":bind"
     (bind-key "<SPC>" md/leader-map evil-normal-state-map)
     (bind-key "<SPC>" md/leader-map evil-visual-state-map)

     (bind-key "h" help-map md/leader-map)  ; I prefer <leader>h to C-h
     (bind-key "n" (lookup-key global-map (kbd "C-x n")) md/leader-map)

     (setq evil-echo-state nil)

     (evil-mode 1))

     ;; Enable evil in the minibuffer. Adapted from
     ;; https://gist.github.com/ccdunder/5816865.
     ;; Not sure why this isn't provided by default.
     ;; (mapc (lambda (keymap)
     ;;           (evil-define-key 'insert (eval keymap) [escape] 'evil-normal-state))
     ;;         ;; https://www.gnu.org/software/emacs/manual/html_node/elisp/
     ;;         ;; Text-from-Minibuffer.html#Definition of minibuffer-local-map
     ;;         '(minibuffer-local-map
     ;;           minibuffer-local-ns-map
     ;;           minibuffer-local-completion-map
     ;;           minibuffer-local-must-match-map
     ;;           minibuffer-local-isearch-map))
     ;; (defun md/evil-minibuffer-setup ()
     ;;   ;; (evil-set-initial-state 'mode 'insert) is the evil-proper
     ;;   ;; way to do this, but the minibuffer doesn't have a mode.
     ;;   (evil-insert 1))
     ;; )
    ;; (add-hook 'minibuffer-setup-hook 'md/evil-minibuffer-setup))

   :bind (;; Like my vimrc, remap  ; to : and , to ;
          :map evil-motion-state-map
          (";" . evil-ex)
          ("," . evil-repeat-find-char)

          ;; Like in the terminal. Mainly useful in minibuffer
          :map evil-insert-state-map
          ("C-a" . move-beginning-of-line)
          ("C-e" . move-end-of-line)

          ;; Use H/L instead of ^/$
          :map evil-normal-state-map
          ("H" . move-beginning-of-line)
          ("L" . move-end-of-line)
          :map evil-visual-state-map
          ("H" . move-beginning-of-line)
          ("L" . move-end-of-line)

          ;; The equivalent of gj/gk
          :map evil-normal-state-map
          ("j" . evil-next-visual-line)
          ("k" . evil-previous-visual-line)

          ;; Leader bindings
          :map md/leader-map
          ("w" . save-buffer)
          ("W" . md/strip-whitespace-and-save)

          ("q" . md/evil-fill)
          ("Q" . md/evil-unfill)

          ;; TODO behave like vim - ie. comment the line or the selection
          ("cc" . comment-or-uncomment-region)

          ;; Buffers
          ("k" . kill-buffer)
          ("bk" . kill-buffer)
          ("bi" . md/file-info)
          ("bw" . save-buffer)
          ("bW" . md/strip-whitespace-and-save)
          ("br" . read-only-mode)
          ("bs" . md/switch-to-buffer-scratch)

          ;; Eval
          ("ef" . eval-defun)
          ("ee" . eval-last-sexp)  ; Bound to e because I'm used to C-x e
          ("eb" . eval-buffer)
          ("er" . eval-region)
          ("ex" . md/fontify-buffer)  ; It's sort-of an eval

          ;; Emacs
          ("Ek" . kill-emacs)
          ("Es" . server-start)

          ;; Packages
          ("Pr" . package-refresh-contents)
          ("Pi" . package-install)
          ("Pl" . package-list-packages)

          ; Toggle misc
          ("tw" . toggle-truncate-lines)

          ;; This could be useful
          ("U" . undo-tree-visualize)

          ;; Same as vim - insert and save
          ("o" . md/insert-blank-line-before)
          ("O" . md/insert-blank-line-after)))

#+END_SRC

** Evil surround
#+BEGIN_SRC emacs-lisp
(use-package evil-surround
 :config
 (progn
   (global-evil-surround-mode 1)))
#+END_SRC

** Easymotion
#+BEGIN_SRC emacs-lisp
(use-package ace-jump-mode

 :config
 (progn
   (setq
    ace-jump-mode-move-keys '(?f ?j ?d ?k ?s ?l ?a ?\; ?g ?h ?r ?u ?e ?i ?w ?o ?t ?y ?b ?v ?n ?c ?m ?x)
    ace-jump-mode-scope 'window  ; If scope is wider than window performance drops a lot
    ace-jump-word-mode-use-query-char nil))

 :bind (:map evil-normal-state-map
             ("f" . nil)
             ("f j" . evil-ace-jump-line-mode)
             ("f k" . evil-ace-jump-line-mode)
             ("f w" . evil-ace-jump-word-mode)
             ("f b" . evil-ace-jump-word-mode)
             ("f f" . evil-ace-jump-char-mode)
             ("f F" . evil-ace-jump-char-mode)
             ("f t" . evil-ace-jump-char-mode)
             ("f T" . evil-ace-jump-char-mode)))
#+END_SRC

** Key Chord
I can't just set my insert mode "jj" and "jk" bindings in the insert-mode-map,
because if I do that then "j" gets assigned as a prefix key, and I can't
actually use it to insert anything in insert mode.

#+BEGIN_SRC emacs-lisp
  (use-package key-chord
    :config
    (progn
      (setq key-chord-two-keys-delay 0.4)

      (key-chord-define evil-insert-state-map "jj" 'md/normal-state-and-save)
      (key-chord-define evil-insert-state-map "jk" 'evil-normal-state)
      (key-chord-mode 1)))
#+END_SRC
* Helm
** Base helm
- [ ] NOTE - describe-function and describe-variable don't use helm until helm
  has been configured. Work out how to load helm when they're called.

#+BEGIN_SRC emacs-lisp
    (use-package helm
      :defer 5
      :config
      (progn
        ;; Putting these bindings here to avoid byte-compiled issue where helm-map isn't defined.
        (helm-mode 1)
        (helm-autoresize-mode 0)

        ;; No need to display the header - it takes up room and doesn't add much.
        (setq helm-display-header-line nil)

        ;; I don't need to know about some files
        ;; TODO get this to workj
        (setq helm-ff-skip-boring-files t)
        (push "\\.$" helm-boring-file-regexp-list)
        (push "\\.\\.$" helm-boring-file-regexp-list)

        ;; This lets me quickly ag/grep for "todo" comments using the same
        ;; ag/grep functions that I usually do.
        (bind-key "C-c C-t" 'md/insert-todo-regexp helm-map)

        ;; Put C-j / C-l the sane way around.
        (bind-key "C-j" 'helm-find-files-up-one-level helm-map)
        (bind-key "C-l" 'helm-execute-persistent-action helm-map)
        (bind-key "C-l" 'helm-execute-persistent-action helm-read-file-map)
        (bind-key "C-l" 'helm-execute-persistent-action helm-find-files-map))

      :bind (([remap find-file] . helm-find-files)  ; Remember - this also opens URLs!
             ([remap occur] . helm-occur)
             ([remap dabbrev-expand] . helm-dabbrev)
             ([remap list-buffers] . helm-buffers-list)
             ("M-x" . helm-M-x)
             ("C-x b" . helm-buffers-list)
             ("C-x p" . helm-mini)

             :map lisp-interaction-mode-map
             ([remap completion-at-point] . helm-lisp-completion)

             :map emacs-lisp-mode-map
             ([remap completion-at-point] . helm-lisp-completion)

             :map md/leader-map
             ("bb" . helm-buffers-list)
             ("f" . helm-find-files)
             ("x" . helm-M-x)
             ("p" . helm-mini)

             :map help-map
             ("X" . helm-colors)))

#+END_SRC

** Addons
#+BEGIN_SRC emacs-lisp
  (use-package helm-ag
    :defer 5
    :config
    (defun md/ag ()
      "Run helm-do-ag on the default-directory"
      (interactive)
      (helm-do-ag default-directory))
    :bind (:map md/leader-map
                ("ag" . md/ag)))
#+END_SRC

* Applications
** Dired
Dired mode has a lot of features / keys that I don't care about. Start it in
evil mode, and just add in the dired bindings that I want.

#+BEGIN_SRC emacs-lisp
  (use-package dired
    :demand t
    :init
    (progn
       ;; Use human size
       (setq dired-listing-switches "-alh")

      ;; evil-integrations.el (https://github.com/emacsmirror/evil/blob/cd005aa50ab056492752c319b5105c38c79c2fd0/evil-integration.el#L111)
      ;; makes dired-mode-map an overriding keymap, which means that the default
      ;; dired-mode bindings take precendence over the normal-state bindings.
      ;;
      ;; There's no obvious way to undo that code, so I'm just replacing
      ;; dired-mode-map with a new keymap that has /not/ been made 'overriding'.
      (setq dired-mode-map (make-sparse-keymap))
      (evil-define-key 'normal dired-mode-map
        "q" 'quit-window
        "d" 'dired-flag-file-deletion
        "u" 'dired-unmark
        "D" 'dired-do-delete
        (kbd "RET") 'dired-single-buffer
        "J" 'dired-jump
        "o" 'dired-find-file-other-window
        "R" 'dired-do-rename
        "C" 'dired-do-copy
        "i" 'dired-maybe-insert-subdir
        "+" 'dired-create-directory)))
#+END_SRC

*** Dired-single

I don't use Dired much and would prefer it to be contained to fewer buffers.
Would like this to work with popwin, but currently pressing RET on a directory
causes it to jump out of the popwin window.

#+BEGIN_SRC emacs-lisp
(use-package dired-single
  :demand t)

#+END_SRC

** Restclient
For 80% of use-cases, I think [[https://github.com/pashky/restclient.el][restclient]] will be more convenient than Postman.

#+BEGIN_SRC emacs-lisp
  (use-package restclient
    :defer 1
    :mode (("\\.http\\'" . restclient-mode)))

  (use-package restclient-helm :defer 5)
#+END_SRC

Add company completion for restclient:

#+BEGIN_SRC emacs-lisp
  (use-package company-restclient
    :config
    (progn
        (add-to-list 'company-backends 'company-restclient)))
#+END_SRC

#+BEGIN_EXAMPLE
POST https://httpbin.org/post

This is the body
#+END_EXAMPLE
* General IDE features
** Autocompletion

Company seems to work nicely without much configuration.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :defer 2
    :config
    (progn
      ;; Bind here rather than in ":bind" to avoid complaints about
      ;; company-mode-map not existing.
      (bind-key "C-n" 'company-select-next company-active-map)
      (bind-key "C-p" 'company-select-previous company-active-map)

      ;; By default this performs company-complete-common, but I don't
      ;; think I'll want to use that
      (bind-key "TAB" 'company-complete-selection company-active-map)

      (bind-key "C-n" 'company-complete evil-insert-state-map)

      (global-company-mode)))
#+END_SRC

** Flycheck
#+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :init
      (progn
        (add-hook 'prog-mode-hook 'flycheck-mode))
      :config
      (progn
        (defface md/modeline-flycheck-error '((t (:inherit 'error))) "")
        (defface md/modeline-flycheck-warning '((t (:inherit 'warning))) "")

        (setq flycheck-flake8rc ".config/flake8"
              flycheck-highlighting-mode 'symbols

              ;; defaults to 0.9, which is too slow
              flycheck-display-errors-delay 0.1

              ;; Disabling this at is annoys me to have errors appearing
              ;; and disappearing quickly and messing with the size of the
              ;; window. I will just check the error list and the fringe.
              flycheck-display-errors-function nil

              ;; There's a short delay when flycheck runs, which causes the modeline to change
              ;; its format (or in my custom powerline stuff, to disappear briefly). It's
              ;; super annoying if this happens at random points during editing, so change it
              ;; to only happen on save (and when enabling the mode). This is quite similar to how
              ;; I had it setup in vim.
              flycheck-check-syntax-automatically '(save mode-enabled)

              flycheck-mode-line-prefix nil)

        ;; For some reason in the flycheck mode list map it just uses all vi
        ;; keys. Mostly this is fine but I need an easy way to quit.
        (evil-define-key 'normal flycheck-error-list-mode-map "q" 'quit-window))
      :bind (:map md/leader-map
                  ;; S prefix, ie. "syntax"
                  ("s <RET>" . flycheck-mode)
                  ("sl" . flycheck-list-errors)
                  ("sn" . flycheck-next-error)
                  ("sj" . flycheck-next-error)
                  ("sp" . flycheck-previous-error)
                  ("sk" . flycheck-previous-error)
                  ("S <RET>" . flyspell-mode)
                  ("SS" . flyspell-correct-word-before-point)))

#+END_SRC

** Projectile
*** Base projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
   :config
   (progn
     (setq projectile-file-exists-local-cache-expire 30
           projectile-enable-caching t
           projectile-globally-ignored-file-suffixes
           '("pyc"
             "png"
             "jpg"
             "gif"
             "zip"
             "Trash"
             "swp"
             "swo"
             "DS_Store"
             "swn"
             "ico"
             "o"
             "elc"
             "a"
             "so"
             "exe"
             "egg-info"
             "egg"
             "dmg")
           projectile-globally-ignored-directories
           '(".tmp"
             ".coverage"
             ".git"
             ".hg"
             ".idea"
             ".flsckout"
             ".bzr"
             "_darcs"
             ".tox"
             ".svn"
             ".egg"
             ".egg-info"
             ".sass-cache"
             "__pycache__"
             ".webassets-cache"
             "node_modules"
             "venv"
             "elpa"
             ".stack-work"))
     (projectile-global-mode))
   :bind (:map md/leader-map
         ("j!" . projectile-invalidate-cache)
         ("jk" . projectile-kill-buffers)))
#+END_SRC

*** Helm
#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :init (progn
            ;; This has to be set before loading helm-projectile
            (setq helm-projectile-fuzzy-match nil))
    :bind (:map md/leader-map
                ("jj" . helm-projectile-switch-project)
                ("jag" . helm-projectile-ag)
                ("jb" . helm-projectile-switch-to-buffer)
                ("jp" . helm-projectile-switch-to-buffer)
                ("jf" . helm-projectile-find-file)))
#+END_SRC

*** Popwin

Sometimes I want popwin buffers to be dedicated to a project, so I can have
eg. one terminal popwin per project.

#+BEGIN_SRC emacs-lisp
  (defun md/projectile-popwin-ansi-term ()
    "Open project-dedicated ansi-term buffer in popwin. Renames the term buffer to
  match the project."
    (interactive)
    (when popwin:focus-window (popwin:close-popup-window))
    (popwin:display-buffer
     (or (get-buffer (format "*ansi-term-(%s)*" (projectile-project-name)))
          (save-window-excursion
            (with-current-buffer
              (call-interactively 'projectile-run-term)
              (rename-buffer
               (format "*ansi-term-(%s)*" (projectile-project-name))))))))

  (defun md/projectile-popwin-shell ()
    "Open project-dedicated shell buffer in popwin. Renames the term buffer to
  match the project."
    (interactive)
    (when popwin:focus-window (popwin:close-popup-window))
    (popwin:display-buffer
     (or (get-buffer (format "*shell-(%s)*" (projectile-project-name)))
          (save-window-excursion
            (with-current-buffer
              (call-interactively 'projectile-run-shell)
              (rename-buffer
               (format "*shell-(%s)*" (projectile-project-name))))))))

  (defun md/projectile-popwin-eshell ()
    "Open project-dedicated eshell buffer in popwin. Renames the term buffer to
  match the project."
    (interactive)
    (when popwin:focus-window (popwin:close-popup-window))
    (popwin:display-buffer
     (or (get-buffer (format "*eshell-(%s)*" (projectile-project-name)))
          (save-window-excursion
            (with-current-buffer
              (call-interactively 'projectile-run-eshell)
              (rename-buffer
               (format "*eshell-(%s)*" (projectile-project-name))))))))

  (bind-key "j;t" 'md/projectile-popwin-ansi-term md/leader-map)
  (bind-key "j;s" 'md/projectile-popwin-shell md/leader-map)
  (bind-key "j;e" 'md/projectile-popwin-eshell md/leader-map)

#+END_SRC

** Git
*** git-gutter
#+BEGIN_SRC emacs-lisp

  (use-package git-gutter
   :init
   (progn
     (defun md/set-sensible-column ()
       "Unless file is too big, either use git-gutter mode (when in
  git dir) or linum mode"
       (interactive)
       (when (< (count-lines (point-min) (point-max)) 2000)
         (if (string= "git" (downcase (format "%s" (vc-backend
                                                    (buffer-file-name
                                                     (current-buffer))))))
             (git-gutter-mode 1)
           (linum-mode 1))))
     (add-hook 'find-file-hook 'md/set-sensible-column))
   :config
   (progn
     (setq git-gutter:ask-p nil  ; Don't ask for confirmation of gadd
           git-gutter:modified-sign "~"
           git-gutter:added-sign "+"
           git-gutter:deleted-sign "-"

           ;; This ensures the separator is always displayed
           git-gutter:unchanged-sign " "
           git-gutter:always-show-separator t

           ;; Without this, there's no space between the git-gutter column and the code.
           git-gutter:separator-sign " "))
   :bind (:map md/leader-map
         ("g <RET>" . git-gutter-mode)
         ("gk" . git-gutter:previous-hunk)
         ("gp" . git-gutter:previous-hunk)
         ("gj" . git-gutter:next-hunk)
         ("gn" . git-gutter:next-hunk)
         ("g+" . git-gutter:stage-hunk)
         ("g-" . git-gutter:revert-hunk)))

#+END_SRC

*** magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
   :config
   (progn
     (evil-set-initial-state 'magit-blame-mode 'normal)
     (evil-set-initial-state 'magit-revision-mode 'normal)

     ;; I don't know why, but by default I can't get magit-blame to adhere to my
     ;; normal-mode map below, even though Evil says I'm in normal mode. Explicitly
     ;; calling evil-normal-state fixes it.
     (add-hook 'magit-blame-mode-hook 'evil-normal-state)
     (evil-define-key 'normal magit-blame-mode-map
       (kbd "<RET>") 'magit-show-commit
       "q" 'magit-blame-quit
       "gj" 'magit-blame-next-chunk
       "gn" 'magit-blame-next-chunk
       "gk" 'magit-blame-previous-chunk
       "gp" 'magit-blame-previous-chunk)

     (add-hook 'magit-revision-mode-hook 'evil-normal-state)
     (evil-define-key 'normal magit-revision-mode-map
       (kbd "<RET>") 'magit-diff-visit-file
       "q" 'magit-mode-bury-buffer))  ;; This quits

   :bind (:map md/leader-map
         ("gm" . magit-dispatch-popup)
         ("gb" . magit-blame)

         ;; NOTE - this doesn't play nicely with mode-line:
         ;; - https://github.com/magit/magit/blob/master/Documentation/magit.org#the-mode-line-information-isnt-always-up-to-date
         ;; - https://github.com/syl20bnr/spacemacs/issues/2172
         ("gc" . magit-checkout)

         ("gd" . magit-ediff-popup)))
#+END_SRC

*** github-browse-file

I miss :Gbrowse from fugitive:

#+BEGIN_SRC emacs-lisp
  (use-package github-browse-file
    :config
    (progn
      (setq github-browse-file-show-line-at-point t))
    :bind (:map md/leader-map
          ("go" . github-browse-file)))
#+END_SRC

** Ediff
#+BEGIN_SRC emacs-lisp
(use-package ediff
 :defer 1
 :config
 (progn
   ;; TODO - I want ediff to have evil-like bindings
   (setq ediff-split-window-function 'split-window-horizontally)))

#+END_SRC
** Highlight keywords in comments

#+BEGIN_SRC emacs-lisp
(use-package fic-mode
 :defer 1
 :init
 (progn
   (add-hook 'prog-mode-hook 'fic-mode))
 :config
 (progn
   ;; NOTE: fic-mode doesn't seem to fontify the buffer, so words don't appear
   ;; highlighted unless either something else fontifies the buffer, or we do it
   ;; manually. Would like to improve this.
   ;;
   ;; FIX: fic-mode doesn't seem to identify words on the same line as my cursor
   ;; when I change theme and then fontify the buffer. All other lines seem fine.

   (setq fic-highlighted-words
         '("TODO" "FIX" "FIXME" "BUG" "WARN" "WARNING" "HACK" "NOTE" "ERROR" "MATT"))

   ;; By default this includes font-lock-string-face, but I don't want strings to
   ;; have these words formatted.
   (setq fic-activated-faces '(font-lock-doc-face font-lock-comment-face))))
#+END_SRC

I can use this with grep/ag to quickly find the todo comments:
#+BEGIN_SRC emacs-lisp
  (defun md/insert-todo-regexp ()
    (interactive)
    (insert "TODO|FIX|FIXME|BUG|WARN|HACK|ERROR"))
#+END_SRC
** Parentheses
Basic paren matching is built in. I preferred these settings at one point,
although I don't remember exactly what the difference is:

#+BEGIN_SRC emacs-lisp
  (use-package paren
   :defer 1
   :init (progn
          (add-hook 'prog-mode-hook 'show-paren-mode))
   :config
   (progn
     (setq show-paren-style 'parenthesis
           blink-matching-paren nil
           blink-matching-paren-on-screen nil)))
#+END_SRC

** Colour hex values
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :defer 1
    :config
    (progn
       (add-hook 'css-mode-hook 'rainbow-mode)
       (add-hook 'help-mode-hook 'rainbow-mode)
       (add-hook 'html-mode-hook 'rainbow-mode))
    :bind (:map md/leader-map
                ("tr" . rainbow-mode)))
#+END_SRC

** COMMENT Folding

#+BEGIN_SRC emacs-lisp
  ;; outline-magic provides org-cycle
  (use-package outline-magic
    :demand t
    :config
    (progn
      ;; TODO - any way to support narrowing? org-narrow-to-subtree works in
      ;; outline mode, but move-subtree-up/down don't work properly when narrowed.

      (add-hook 'prog-mode-hook 'outline-minor-mode)

      (defun md/outline-cycle-all ()
        (interactive)
        (let ((current-prefix-arg '(4))) ;; emulate C-u
          (call-interactively 'outline-cycle)))

      (defun md/outline-next-heading ()
        "Automatically move point to first word beyond any leading whitespace"
        (interactive)
        (outline-next-visible-heading 1)
        (back-to-indentation))

      (defun md/outline-previous-heading ()
        "Automatically move point to first word beyond any leading whitespace"
        (interactive)
        (outline-previous-visible-heading 1)
        (back-to-indentation))

      (setq outline-blank-line nil)
      (evil-define-key 'normal outline-minor-mode-map
        (kbd "<tab>") 'outline-cycle
        (kbd "S-<tab>") 'md/outline-cycle-all
        "gk" 'md/outline-previous-heading
        "gj" 'md/outline-next-heading
        (kbd "M-k") 'outline-move-subtree-up
        (kbd "M-j") 'outline-move-subtree-down)

      ;; TODO - add decorator support?
      (defun md/outline-minor-mode-python ()
        (interactive)
        (setq-local outline-regexp
                    (rx-to-string
                     '(group (* space)
                             (* "#")
                             (* space)
                             bow
                             (or "class" "def")
                             ))))
      (add-hook 'python-mode-hook 'md/outline-minor-mode-python)
      ))
#+END_SRC

* Languages
** Python

Elpy combines a few different Python packages / features.

#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :defer 1  ;; Defer this just because it's slow to load.
    :init
    (progn
      (add-hook 'elpy-mode-hook
                (lambda ()
                  (set (make-local-variable 'company-backends) '(elpy-company-backend)))))
    :config
    (progn
      (elpy-enable)

      ;; - Remove elpy-module-flymake because I already have flymake configured.
      ;; - Remove elpy-module-highlight indentation because it's distracting.
      (setq elpy-modules (list
                          'elpy-module-sane-defaults
                          'elpy-module-company
                          'elpy-module-eldoc
                          'elpy-module-pyvenv
                          'elpy-module-yasnippet))

      (setq elpy-rpc-backend "jedi")

      ;; Setup leader map for python
      (evil-define-key 'normal python-mode-map
        (kbd "SPC") md/python-mode-leader-map
        "gk" 'python-nav-backward-defun
        "gj" 'python-nav-forward-defun)

      (evil-define-key 'insert elpy-mode-map (kbd "C-n") 'elpy-company-backend)

      (if (string= major-mode "python-mode")
        (progn
          ;; If I've opened a Python file make sure everything loads properly
          ;; on this buffer.
          (python-mode)
          (elpy-mode 1))))

    :bind (:map md/python-mode-leader-map
                ("SPC v" . pyvenv-workon)
                ("SPC V" . pyvenv-activate)
                ("SPC f" . elpy-format-code)
                ("SPC t" . elpy-test)
                ("SPC d" . elpy-doc)
                ("SPC g" . elpy-goto-definition-other-window)
                ("SPC r" . elpy-multiedit-python-symbol-at-point)))

#+END_SRC

** Golang
#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :config
    (progn
      (add-hook 'before-save-hook 'gofmt-before-save)

      ;; Make sure SPC uses the go-mode leader map rather than my default leader
      ;; map
      (evil-define-key 'normal go-mode-map
        (kbd "SPC") md/go-mode-leader-map))

    :bind (:map md/go-mode-leader-map
                ("SPC =" . gofmt)))

  (use-package company-go
    :init
    (progn
      (add-hook 'go-mode-hook
                (lambda ()
                  (set (make-local-variable 'company-backends) '(company-go))))))

#+END_SRC

** MIT Scheme

- [ ] mit-scheme leader map
- [ ] ef / ee / er bindings
#+BEGIN_SRC emacs-lisp

  (use-package scheme
    :config
    (progn
      ;; For SICP
      (setq scheme-program-name "/usr/local/bin/mit-scheme")

      ;; Setup leader map for this major mode
      (evil-define-key 'normal scheme-mode-map
        (kbd "SPC") md/scheme-mode-leader-map)
      (evil-define-key 'visual scheme-mode-map
        (kbd "SPC") md/scheme-mode-leader-map)

      ;; When I run the "send-to" functions I want to see the results
      ;; in the popwin window
      (defun md/scheme--eval (fn)
        (save-window-excursion
          (call-interactively 'run-scheme))
          (call-interactively fn)
        (popwin:display-buffer (get-buffer "*scheme*")))

      (defun md/scheme-send-last-sexp ()
        (interactive)
        (md/scheme--eval 'scheme-send-last-sexp))

      (defun md/scheme-send-region ()
        (interactive)
        (md/scheme--eval 'scheme-send-region))

      (defun md/scheme-send-defun ()
        (interactive)
        (md/scheme--eval 'scheme-send-definition)))

    :bind (:map md/scheme-mode-leader-map
                ("SPC ee" . md/scheme-send-last-sexp)
                ("SPC ef" . md/scheme-send-defun)
                ("SPC er" . md/scheme-send-region)))
#+END_SRC
** Yaml
Not sure if this provides anything beyond syntax highlighting, but that's enough
for now:

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode)
#+END_SRC

** Lua

#+BEGIN_SRC emacs-lisp
  (use-package lua-mode)
#+END_SRC

** Terraform
Not sure if this provides anything beyond syntax highlighting, but that's enough
for now:

#+BEGIN_SRC emacs-lisp
  (use-package terraform-mode)
#+END_SRC

** Web mode
This makes working with HTML/CSS/JS files much nicer. TODO - read documentation
/ configure.

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :defer 1)

#+END_SRC

** Markdown

AFAICT markdown syntax highlighting isn't provided by default. [[https://github.com/jrblevin/markdown-mode][Markdown mode]]
includes highlighting, plus some extra features like inserting elements and
compiling. It also includes ~gfm-mode~ for Github-flavoured markdown.

NOTE - compiling requires ~markdown~ to be installed.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode)))
#+END_SRC
* Help
** help-fns+
This package provides ~describe-keymap~ to M-k in the help-map, which is
handy. It does some other things too (TODO - read docs).

#+BEGIN_SRC emacs-lisp
(use-package help-fns+ :defer 1)
#+END_SRC

** Help mode
I prefer to use vi keys to navigate help-mode:

#+BEGIN_SRC emacs-lisp
  (evil-set-initial-state 'help-mode 'normal)
  (evil-define-key 'normal help-mode-map
    "q" 'quit-window
    (kbd "C-i") 'help-go-forward
    (kbd "C-o") 'help-go-back
    (kbd "<RET>") 'help-follow-symbol)
#+END_SRC

** Which-key

[[https://github.com/justbur/emacs-which-key][which-key]] displays available bindings for the current prefix, which makes it
easier to discover features / work out where I am:

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :defer 2
    :config
    (progn
      (setq which-key-idle-delay 0.5
            which-key-max-description-length 30
            which-key-allow-evil-operators nil
            which-key-show-operator-state-maps nil)

      ;; Use ESC/C-g to quit which-key. Not sure why the default key is 'a'.
      (bind-key "ESC" 'which-key-abort which-key-C-h-map)
      (bind-key "C-g" 'which-key-abort which-key-C-h-map)

      (which-key-declare-prefixes
        "SPC SPC" "major-mode"
        "SPC SPC e" "major-mode-eval"
        "SPC b" "buffers"
        "SPC c" "comments"
        "SPC C" "compile"
        "SPC e" "eval"
        "SPC E" "Emacs"
        "SPC g" "git"
        "SPC h" "help"
        "SPC j" "project"
        "SPC j ;" "project-popwin"
        "SPC n" "narrow"
        "SPC P" "Packages"
        "SPC s" "flycheck"
        "SPC S" "flyspell"
        "SPC t" "toggle-misc"
        "SPC v" "dotfiles"
        "SPC ;" "popwin")
      (which-key-mode)))
#+END_SRC

** List unbound keys

This is handy sometimes - it provides ~free-keys~, which lists unbound keys.

#+BEGIN_SRC emacs-lisp
  (use-package free-keys
    :defer 10
    :config
      (progn
        (bind-key "@" 'free-keys help-map)))
#+END_SRC

* Window manager
** Elscreen

Elscreen provides "tabs" that let me sort of arrange windows how I did it in
vim. They're not ideal though, because the tabs either appear in several places
on the screen, or nowhere.

#+BEGIN_SRC emacs-lisp
  (use-package elscreen
   :defer 1
   :config
   (progn
     (defun md/elscreen-display-tabs ()
       (interactive)
       (setq elscreen-display-tab t
             elscreen-tab-display-kill-screen nil
             elscreen-tab-display-control nil)

       ;; This is how elscreen redraws
       (elscreen-notify-screen-modification 'force))

     (md/elscreen-display-tabs)))
#+END_SRC

** Splitscreen
#+BEGIN_SRC emacs-lisp
(setq md/splitscreen-path (md/dotfiles-get-path "splitscreen/"))

;; NOTE - for some reason this doesn't seem to load with "defer"
(use-package splitscreen
 :load-path md/splitscreen-path
 :demand t
 :config
 (progn
   (splitscreen-mode)))
#+END_SRC
** Popwin

https://github.com/m2ym/popwin-el.

Popwin helps bring some sanity to Emacs windows. By default, Emacs tends to
clobber the windows that I'm working on with various other applications
(eg. for help, flycheck, shell/term). Popwin lets me contain all of these
less-important buffers in a single window and then dismiss it. This way they
don't interfere with the buffers I'm actually working on.

It hasn't been maintained for a while, but hopefully I won't see too many rough
edges.

#+BEGIN_SRC emacs-lisp
  (use-package popwin
    :demand t
    :config
    (progn
      (defun md/popwin-toggle ()
        "Either close popwin or open it in its last buffer"
        (interactive)
        (if popwin:focus-window
            (popwin:close-popup-window)
          (popwin:display-last-buffer)))

      (defun md/popwin-org ()
        (interactive)
        (when popwin:focus-window (popwin:close-popup-window))
        (if (get-buffer "index.org")
            (popwin:display-buffer "index.org")
          (message "No buffer: index.org")))

      (defun md/popwin-scratch ()
        (interactive)
        (when popwin:focus-window (popwin:close-popup-window))
        (popwin:display-buffer "*scratch*"))

      (defun md/popwin-messages ()
        (interactive)
        (when popwin:focus-window (popwin:close-popup-window))
        (popwin:display-buffer "*Messages*"))

      (defun md/popwin-ansi-term ()
        "Copied from
  https://github.com/m2ym/popwin-el/blob/master/misc/popwin-term.el. For some
  reason this is necessary to open term in a popwin window. Shell and eshell work
  out of the box."
        (interactive)
        (when popwin:focus-window (popwin:close-popup-window))
        (popwin:display-buffer
         (or (get-buffer "*ansi-term*")
             (save-window-excursion
               (call-interactively 'ansi-term)))))

      (defun md/popwin-eshell ()
        (interactive)
        (when popwin:focus-window (popwin:close-popup-window))
        (popwin:display-buffer
         (or (get-buffer "*eshell*")
             (save-window-excursion
               (call-interactively 'eshell)))))

      (defun md/popwin-dired-single ()
        (interactive)
        (when popwin:focus-window (popwin:close-popup-window))
        (popwin:display-buffer
         (or (get-buffer dired-single-magic-buffer-name)
             (save-window-excursion
               (call-interactively 'dired-single-magic-buffer)))))

      ;; Disable popwin-mode in an active Helm session, to prevent it from conflicting
      ;; with Helm windows. Also ensure that popwin-last-config doesn't return
      ;; helm buffers.
      (defvar md/popwin-last-config nil)
      (add-hook 'helm-before-initialize-hook
                (lambda ()
                  (message "HOOK")
                  (when popwin:focus-window (progn (message "CLOSING" (popwin:close-popup-window))))))
      (add-hook 'helm-after-initialize-hook
                (lambda ()
                  (setq md/popwin-last-config-store popwin:popup-last-config)
                  (popwin:display-buffer helm-buffer t)
                  (popwin-mode -1)
                  ))
      (add-hook 'helm-cleanup-hook (lambda ()
                                     (popwin-mode 1)
                                     (setq popwin:popup-last-config md/popwin-last-config-store)))
      (push '("^\*helm.+\*$" :regexp t :dedicated nil :height 15) popwin:special-display-config)

      (setq popwin:popup-window-height 10)

      ;; TODO why isn't dired working? Judging by the examples it should, but
      ;; dired buffers just appear in their own windows. Tried on 24.5 and 25.1.
      (push '(dired-mode :dedicated nil :width 40) popwin:special-display-config)

      ;; NOTE: `:dedicated t` means matching buffers will reuse the same window.
      ;; Generally I only ever want one popwin window open.
      (push '("*Messages*" :tail t :dedicated t) popwin:special-display-config)
      (push '("index.org" :height 20 :dedicated t :stick t) popwin:special-display-config)
      (push '(help-mode :dedicated t) popwin:special-display-config)
      (push '("^\\*scratch\\*$" :regexp t :dedicated t :stick t) popwin:special-display-config)
      (push '("^\\*Flycheck.+\\*$" :regexp t :dedicated t :stick t :noselect t) popwin:special-display-config)
      (push '("*Messages*" :tail t :dedicated t) popwin:special-display-config)
      (push '("*Warnings*" :tail t :dedicated t) popwin:special-display-config)
      (push '("*Backtrace*" :dedicated t) popwin:special-display-config)
      (push '(completion-list-mode :noselect t :dedicated t) popwin:special-display-config)
      (push '(compilation-mode :noselect t :stick t :dedicated t :tail t) popwin:special-display-config)
      (push '(grep-mode :noselect t :dedicated t) popwin:special-display-config)
      (push '(occur-mode :noselect t :dedicated t) popwin:special-display-config)
      (push '("*vc-change-log*" :dedicated t) popwin:special-display-config)
      (push '("*undo-tree*" :width 60 :position right :dedicated t) popwin:special-display-config)
      (push '("*HTTP Response*" :height 20 :dedicated t :stick t :noselect t) popwin:special-display-config)
      (push '("*Shell Command Output*" :dedicated t :tail t) popwin:special-display-config)
      (push '("*Async Shell Command*" :dedicated t :tail t) popwin:special-display-config)
      (push '(shell-mode :regexp t :dedicated t :height 15 :stick t :tail t) popwin:special-display-config)
      (push '(eshell-mode :regexp t :dedicated t :height 15 :stick t :tail t) popwin:special-display-config)
      (push '(term-mode :dedicated t :height 15 :stick t :tail t)
            popwin:special-display-config)  ; only works with md/popwin-ansi-term
      (push '(inferior-scheme-mode :dedicated t :height 15 :stick t :tail t) popwin:special-display-config)

      (popwin-mode 1))
    :bind (:map md/leader-map
                ;; I can't get arbitrary buffers/files to play nicely, so
                ;; just have the dedicated buffers.
                (";a" . md/popwin-toggle)
                (";d" . md/popwin-dired-single)
                (";i" . md/popwin-org)
                (";s" . md/popwin-scratch)
                (";t" . md/popwin-ansi-term)
                (";e" . md/popwin-eshell)
                (";m" . md/popwin-messages)))
#+END_SRC

* Org mode

** org-mode
#+BEGIN_SRC emacs-lisp
    (use-package org
     :defer 5
     :config
     (progn

       (defun md/org-timestamp-time-inactive-no-confirm ()
         (interactive)
         (org-insert-time-stamp (current-time) t t))

       (defun md/org-timestamp-date-inactive-no-confirm ()
         (interactive)
         (org-insert-time-stamp (current-time) nil t))

       (defun md/org-insert-link-from-paste ()
         (interactive)
         (org-insert-link nil
                          (with-temp-buffer
                            (evil-paste-after nil)
                            (delete-trailing-whitespace)
                            (buffer-string))))

       (defun md/org-hook ()
         ;; Change tab widths to fit headline indents
         (setq tab-width 2
               evil-shift-width 2)

         ;; Disable in-buffer line numbers and the colour column, as both decrease
         ;; org-mode / outline performance significantly on large files.
         (linum-mode 0)
         (fci-mode 0)

         ;; Also disable the row and column numbers in the modeline. Seems you have to set
         ;; these manually to make them buffer-local, unlike the above functions - TODO
         ;; is this a bad thing?
         (setq-local line-number-mode nil)
         (setq-local column-number-mode nil)

         ;; Also don't highlight the current line. For some reason this rquires making
         ;; global-hl-line-mode buffer-local.
         (make-variable-buffer-local 'global-hl-line-mode)
         (setq-local global-hl-line-mode nil))

       (define-minor-mode md/evil-org-mode
         "Buffer local minor mode for evil-org"
         :init-value nil
         :lighter " EvilOrg"
         :keymap (make-sparse-keymap) ; defines md/evil-org-mode-map
         :group 'md/evil-org)

       ;; NOTE - I don't think the use-package ":bind" arg allows defining evil keys
       ;; for a specific evil-mode/map combination.

       ;; Normal state shortcuts
       (evil-define-key 'normal md/evil-org-mode-map
         "gk" 'outline-previous-visible-heading
         "gj" 'outline-next-visible-heading
         "H" 'org-beginning-of-line
         "L" 'org-end-of-line
         "$" 'org-end-of-line
         "^" 'org-beginning-of-line
         "-" 'org-cycle-list-bullet
         (kbd "RET") 'org-cycle
         (kbd "TAB") 'org-cycle)

       ;; Normal & insert state shortcuts.
       (mapc (lambda (state)
               (evil-define-key state md/evil-org-mode-map
                 (kbd "M-l") 'org-metaright
                 (kbd "M-h") 'org-metaleft
                 (kbd "M-k") 'org-metaup
                 (kbd "M-j") 'org-metadown
                 (kbd "M-L") 'org-shiftmetaright
                 (kbd "M-H") 'org-shiftmetaleft
                 (kbd "M-K") 'org-shiftmetaup
                 (kbd "M-J") 'org-shiftmetadown
                 ))
             '(normal insert))

       ;; I don't like the default org-agenda bindings - there are far more
       ;; bindings/features than I should have to think about, and I usually try to
       ;; navigate using evil bindings (and eg. accidentally hit "j" and bring up
       ;; the calendar etc).
       ;;
       ;; Instead, open org-agenda in evil-normal-mode, with a couple of the useful
       ;; bindings copied directly from emacs-mode.
       (define-minor-mode md/evil-org-agenda-mode
         "Buffer local minor mode for evil-org-agenda"
         :init-value nil
         :lighter " EvilOrgAgenda"
         :keymap (make-sparse-keymap) ; defines md/evil-org-agenda-mode-map
         :group 'md/evil-org-agenda)

       (evil-set-initial-state 'org-agenda-mode 'normal)

       (evil-define-key 'normal md/evil-org-agenda-mode-map
         ;; j / k
         (kbd "j") 'org-agenda-next-line
         (kbd "n") 'org-agenda-next-line
         (kbd "C-n") 'org-agenda-next-line
         (kbd "k") 'org-agenda-previous-line
         (kbd "p") 'org-agenda-previous-line
         (kbd "C-p") 'org-agenda-previous-line

         (kbd "q") 'org-agenda-quit
         (kbd "r") 'org-agenda-redo  ; Recalculate the agenda
         (kbd "v") 'org-agenda-view-mode-dispatch  ; Alter the view
         (kbd "|") 'org-agenda-filter-remove-all  ; Remove existing filters
         (kbd "=") 'org-agenda-filter-by-regexp  ; Search
         (kbd "/") 'org-agenda-filter-by-tag  ; Tag filter
         (kbd "^") 'org-agenda-filter-by-top-headline  ; Show other items with same
                                            ; headline as current
         (kbd "A") 'org-agenda-append-agenda)  ; Add another agenda

       (add-hook 'org-mode-hook 'md/org-hook)
       (add-hook 'org-mode-hook 'md/evil-org-mode)
       (add-hook 'org-agenda-mode-hook 'md/evil-org-agenda-mode)

       (setq org-agenda-restore-windows-after-quit t

             ;; Add timestamp when set task as closed
             org-log-done 'time

             ;; Fontify inline code
             org-src-fontify-natively t

             ;; When editing code, I don't want to open another window. This
             ;; just makes the screen tidier.
             org-src-window-setup 'current-window

             ;; tab / indentation is the main reason I would use C-' so prevent it if possible
             org-src-tab-acts-natively t

             ;; Colour the whole headline
             org-level-color-stars-only nil

             ;; Try to prevent accidentally editing invisible lines
             org-catch-invisible-edits 'show-and-error

             org-adapt-indentation nil

             org-clock-out-remove-zero-time-clocks t

             ;; If press M-RET I want a new line, not to split the line
             org-M-RET-may-split-line nil

             ;; Default to using my CSS theme for html exports
            ;; org-html-head-extra "
            ;;<link id='generic-css-dark' rel='stylesheet' type='text/css'
            ;;      href='https://mattduck.github.io/generic-css/css/generic-dark.css'>
            ;;<link id='generic-css-light' rel='stylesheet' type='text/css'
            ;;      href='https://mattduck.github.io/generic-css/css/generic-light.css'>
            ;;<script type='text/javascript'src='https://mattduck.github.io/generic-css/js/generic-css.js'></script>"

             org-export-headline-levels 6
             org-export-with-section-numbers 4)


       ;; Putting these here to avoid byte-compiled issue where org-mode-map isn't defined.
       (bind-key "C-c d" 'md/org-timestamp-date-inactive-no-confirm org-mode-map)
       (bind-key "C-c t" 'md/org-timestamp-time-inactive-no-confirm org-mode-map)
       (bind-key "C-c l" 'md/org-insert-link-from-paste org-mode-map))
     :bind (:map global-map
           ("C-c a" . org-agenda)))

#+END_SRC
** ox-reveal

- Export org-mode files to reveal.js for presentations. I think this works
  quite nicely.

#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal)
#+END_SRC

* Modeline
** General modeline
#+BEGIN_SRC emacs-lisp
(line-number-mode 1)
(column-number-mode 1)
#+END_SRC

** Powerline
#+BEGIN_SRC emacs-lisp
  (use-package powerline
   :defer 1
   :config
   (progn
     (defface md/powerline-inactive '((t (:inherit 'modeline))) "")
     (defface md/powerline-normal '((t (:inherit 'modeline))) "")
     (defface md/powerline-insert '((t (:inherit 'modeline))) "")
     (defface md/powerline-visual '((t (:inherit 'modeline))) "")
     (defface md/powerline-replace '((t (:inherit 'modeline))) "")
     (defface md/powerline-emacs '((t (:inherit 'modeline))) "")
     (defun md/powerline-setup ()
       (interactive)
       (require 'flycheck)
       (setq-default mode-line-format
                     '("%e"
                       (:eval
                        (let* ((active (powerline-selected-window-active))
                               (mode-line (if active 'mode-line 'mode-line-inactive))
                               (face1 (if active 'powerline-active1 'powerline-inactive1))
                               (face2 (if active 'powerline-active2 'powerline-inactive2))

                               ;; Set face3 depending on Evil state
                               (face3 (if active
                                          (cond ((evil-normal-state-p) 'md/powerline-normal)
                                                ((evil-insert-state-p) 'md/powerline-insert)
                                                ((evil-visual-state-p) 'md/powerline-visual)
                                                ((evil-replace-state-p) 'md/powerline-replace)
                                                ((evil-emacs-state-p) 'md/powerline-emacs)
                                                (t 'md/powerline-normal))
                                        'md/powerline-inactive))
                               (separator-left (intern (format "powerline-%s-%s"
                                                               (powerline-current-separator)
                                                               (car powerline-default-separator-dir))))
                               (separator-right (intern (format "powerline-%s-%s"
                                                                (powerline-current-separator)
                                                                (cdr powerline-default-separator-dir))))

                               (lhs (list
                                     ;; Line / column numbers
                                     (when (or line-number-mode column-number-mode)
                                       (cond ((and line-number-mode
                                                   column-number-mode)
                                              (powerline-raw "%4l:%2c " face3 'l))
                                             (line-number-mode
                                              (powerline-raw "%4l" face3 'l))
                                             (column-number-mode
                                              (powerline-raw ":%2c " face3 'l))))

                                     ;; Evil status
                                     (powerline-raw evil-mode-line-tag face3 'l)
                                     (funcall separator-left face3 face1)

                                     ;; Major mode
                                     (powerline-raw (format "*%s* " (powerline-major-mode)) face1 'l)
                                     (funcall separator-left face1 mode-line)

                                     ;; Projectile project
                                     (if (and (boundp 'projectile-mode) projectile-mode)
                                         (powerline-raw (concat (projectile-project-name) "::%b") 'l)
                                       (powerline-raw "%b" mode-line 'l))

                                     ;; File state
                                     (when (buffer-modified-p)
                                       (powerline-raw "+" mode-line 'l))
                                     (when buffer-read-only
                                       (powerline-raw "[RO]" mode-line 'l))
                                     (when (buffer-narrowed-p)
                                       (powerline-raw "  Narrow" mode-line 'l))
                                     (when (and active (fboundp 'org-clocking-p) (org-clocking-p))
                                       (powerline-raw
                                        (propertize
                                         (format "  %s "
                                                 (if (> (length org-mode-line-string) 50)
                                                     (format "%s..." (string-trim (substring org-mode-line-string 0 50)))
                                                   org-mode-line-string))
                                         'face nil)
                                        mode-line 'l))))

                               (rhs (list

                                     ;; Git
                                     (funcall separator-right mode-line face1)
                                     (powerline-vc face1 'r)

                                     ;; Flycheck
                                     (when (and active flycheck-mode (flycheck-has-current-errors-p))
                                       (powerline-raw
                                        (format " [line:%s (%s)] "
                                                ;; Line of first err
                                                (save-excursion
                                                  (flycheck-first-error)
                                                  (+ 1 (count-lines (point-min) (point))))
                                                ;; Total lines
                                                (length flycheck-current-errors))

                                        ;; Face
                                        (cond ((flycheck-has-current-errors-p 'error)
                                               'md/modeline-flycheck-error)
                                              ((flycheck-has-current-errors-p 'warning)
                                               'md/modeline-flycheck-warning))
                                        'r))
                                     )))
                          (concat (powerline-render lhs)
                                  (powerline-fill mode-line (powerline-width rhs))
                                  (powerline-render rhs)))))))

     (defun md/powerline-reset ()
       (interactive)
       (setq mode-line-format (md/powerline-setup))
       (solarized-load-theme))

     (md/powerline-setup)
     (md/powerline-reset)))
#+END_SRC
* Solarized theme

#+BEGIN_SRC emacs-lisp
  (use-package color-theme-solarized
   :demand t
   :ensure nil
   :load-path "non-elpa/color-theme-solarized"
   :config
   (progn
     (add-to-list 'custom-theme-load-path "non-elpa/color-theme-solarized")

     ;; Necessary on v24.4 to display accurate Solarized colors, due to Emacs bug
     ;; #8402. v24.3 didn't set ns-use-sgrb-colorspace.
     (setq ns-use-srgb-colorspace nil
           solarized-broken-srgb t)

     ;; See heading on terminal colour fixes near top of file
     (when (not (display-graphic-p))
       (setq solarized-bold nil))

     (load-theme 'solarized t)  ; Defaults to light
     (solarized-enable-theme 'dark))

   :bind (:map md/leader-map
          ("ts" . solarized-toggle-theme-mode)
          ("cs" . solarized-toggle-comment-visibility)))
#+END_SRC

* Dotfiles

#+BEGIN_SRC emacs-lisp
  (defun md/dotfiles-edit-init ()
    (interactive)
    (find-file (md/dotfiles-get-path "emacs.d.symlink/init.org")))

  (defun md/dotfiles-compile ()
    (interactive)
    (find-file (md/dotfiles-get-path "emacs.d.symlink/init.org"))
    (setq-local org-confirm-babel-evaluate nil)
    (org-babel-tangle nil "init.el")
    (byte-compile-file (md/dotfiles-get-path "emacs.d.symlink/init.el")))

  (bind-key "ve" 'md/dotfiles-edit-init md/leader-map)
  (bind-key "vc" 'md/dotfiles-compile md/leader-map)
#+END_SRC

* Profile Emacs startup

Running ~esup~ will start Emacs and profile the startup time. To get GUI on par
w/terminal, I can disable exec-path-from-shell.

#+BEGIN_SRC emacs-lisp
(use-package esup
  :defer 5)
#+END_SRC

* Teardown

Profiling. This number comes out slightly different to ~(emacs-init-time)~

#+BEGIN_SRC emacs-lisp
(defconst md/emacs-init-end (current-time))

(defconst md/emacs-boot-time (float-time (time-subtract md/emacs-init-end md/emacs-init-start)))
(message (format "md/emacs-boot-time: %s" md/emacs-boot-time))

#+END_SRC

Close paren for the wrapping ~let~:

#+BEGIN_SRC emacs-lisp
)
#+END_SRC

* TODO
- [ ] tab key not inserting tabs in evil?
  - it aligns but doesn't insert tab, not sure if this is behaviour i want. It
    runs indent-for-tab-command. Try it for a while.
- [ ] read electric-indent docs.
- [ ] does electric-indent need different configuration in python? I used to
  have something for this.
- [ ] info / other help modes - use vi keys to navigate?
- [ ] how to preserve binding in map?
  - Eg. I want to use normal mode for some magit modes, but I generally want to retain
    the behaviour of RET. This is true for help modes too.
- [ ] jumping to definitions
  - Under cursor, and by name
- [ ] finding uses of functions
  - Under cursor, and by name
- [ ] ediff / git diff
- [ ] checkout avy - improvement to acejump?
- [ ] debugger
- [ ] folding
  - I basically want tab/shift+tab toggle bindings like outline mode. But
    outline mode doesn't match folding blocks nicely, so need to use another package.
- [ ] autocomplete
- [ ] checkout slime
- [ ] jumping forward/back to markers including between files
- [ ] stop littering # backup files
- [ ] startup time?
  - bottleneck is down to ~(package-initialize)~ and evil startup.
  - elpy is slow.
- [ ] https://github.com/emacs-tw/awesome-emacs
  - [ ] multi cursor?
- [ ] gk/gj for next/prev functions
- [ ] why can't I select something and then paste when in visual mode? This used
  to work
  - [2016-07-08 Fri] seem to work now?
- [ ] [2016-08-20 Sat] getting helm "operator" keymap error in fundamental mode.
- [ ] python development / elpy
  - [ ] open documentation
  - [ ] run tests
  - [ ] refactoring
- [ ] the elpy flycheck colours aren't bad, and work in terminal - consider
  using them for full flycheck.
- [ ] eldoc mode?
- [ ] check company addons
  - there's one for restclient.
- [ ] helm-projectile-find-file is worse than ctrlp
  - slower
  - no ag ignore
- [ ] grep / ag results should hang around in popwin window
- [ ] go mode
- [ ] org - shortcut to add =- [ ]= syntax to beginning of line
- [ ] cask?
- [2016-09-24 Sat] elscreen not actively developed
- [ ] popwin is useful
  - why can't match dired or some of the term modes?
    - dired doesn't match even with helm disabled and all other dired config
      disabled.
    - HEAD and 25 is same. So is 24.
    - can forget this if ansi-term works
  - shortcut for jumping to a restclient file?
    - or opening new restclient buffer?
- [ ] spacemacs - provide anything good?
  - [ ] paradox-list-packages
  - [ ] a prefix - applications
  - [ ] list-processes?
  - [ ] undo tree visualiser?
  - [ ] ! to execute shell command
  - [ ] c - compiling
    - helm-make-projectile
    - helm-make
    - compile
    - recompile
    - projectile-compile is under
  - [ ] f - file prefix
    - dired jump
    - open in external app
    - neotree toggle looks cool
  - [ ] i - insert prefix
  - [ ] p - projectile run shell
    - and async
    - projectile-compile
    - multi-occur
    - neotree
  - [ ] q - some quit functions
    - kill-emacs
    - restart-emacs-resume-layouts?
  - [ ] s - search prefix
    - "smart" search?
  - [ ] S - symbol highlight. Is this useful?
  - [ ] t / T - various toggles, eg. linum, line wrapping. Perhaps solarized bg mode.
  - [ ] w - window commands. The popup window looks like it might be good
    - for messages, compiling, generally temp stuff.
  - [ ] z - zoom text
- [ ] Emacs 25 / package upgrades
  - [2016-09-24 Sat] just upgraded everything
  - [ ] not getting native colours in org-mode code blocks, despite
    fontify-natively t.
  - [ ] faces buffer doesn't show right face colors? they're all white-/grey.
- [ ] helm-all-mark-rings?
- [ ] persist helm grep buffer
- [ ] helm grep within current file - currently don't have binding for this.
- [ ] check spacemacs - are there any modes we can evilify? eg. some of the help modes.
- [ ] python shell / inferior?
- [ ] getting slowdowns where python3 uses 99% cpu. Seems to occcur sometimes
  when killing buffers. Only python processes running are doing ~elpy.__main__~.
  - This process is started in elpy-rpc--open.
  - https://github.com/jorgenschaefer/elpy/issues/724
  - Next time this happens use strace and try to report bug.
  - https://github.com/jorgenschaefer/elpy/issues/96
- [ ] info page for intro to emacs lisp
- [ ] use-package - is there a way to reload :binds?
- [ ] browse documentation?
  - for eg. ansible
- [ ] [2016-11-30 Wed] get C-O/C-I jumping forward/back in dired.
- [ ] helm buffers - how to search including the mode? Eg. "dired" should match
  the "Dired by name" buffers.
- [ ] [2016-11-30 Wed] dired popwin should NOT jump out a window when pressing RET.
- [ ] [2016-11-30 Wed] popwin dired - display on side instead of bottom?
