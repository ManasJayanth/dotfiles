#+TITLE init.org
* Compile

I'm using org-mode to structure my configuration. Inspired by [[https://github.com/sachac/.emacs.d][Sacha Chua]] and
[[https://github.com/eschulte/emacs24-starter-kit/][Emacs Starter Kit]].

#+BEGIN_SRC emacs-lisp :results silent :tangle no
(setq-local org-confirm-babel-evaluate nil)
(org-babel-tangle nil "init.el")

;; Byte-compiling seems to take ~0.1s off startup time.
(byte-compile-file "init.el")
#+END_SRC

* Initialise

** Profiling
#+BEGIN_SRC emacs-lisp
(defconst md/emacs-init-start (current-time))
#+END_SRC

** Init performance optimising

This wraps the rest of the file.

- Increase the GC threshold to 100MB. This decreases Emacs load time by approx
  600ms when not using ~use-package~. With ~use-package~, it still decreases load
  time by 250ms.

- The default file-handler-name-alist contains some regexps that are run against
  every .el/.elc loaded on startup. Preventing this apparently decreases load
  time, although I haven't noticed much.

#+BEGIN_SRC emacs-lisp
  (let ((file-handler-name-alist nil)
         (gc-cons-threshold 100000000))
#+END_SRC

** Dotfiles

I use this to refer to this directory / file:

#+BEGIN_SRC emacs-lisp
(defun md/get-dotfiles-path ()
  (or
    (getenv "DOTFILES")
    (concat (expand-file-name "~") "/dotfiles")))
#+END_SRC

** Emacs Package setup
#+BEGIN_SRC emacs-lisp
;; NOTE - this is old, maybe I can remove it
(defun md/refresh-packages ()
  (interactive)
  (when (not package-archive-contents)
    (package-refresh-contents)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (package-initialize)

    (setq package-archives
          '(("gnu" . "http://elpa.gnu.org/packages/")
            ("marmalade" . "http://marmalade-repo.org/packages/")
            ("melpa" . "http://melpa.milkbox.net/packages/")
            ("org" . "http://orgmode.org/elpa/")))

    (setq load-prefer-newer t)  ; new in v24.4
#+END_SRC

** Custom file

#+BEGIN_SRC emacs-lisp
(setq custom-file (concat (md/get-dotfiles-path) "/emacs.d.symlink/custom.el"))
(load custom-file 'noerror)
#+END_SRC

** use-package setup

If ~use-package~ isn't installed, I should install it.

#+BEGIN_SRC emacs-lisp
(setq use-package-always-ensure nil
      use-package-verbose t
      use-package-minimum-reported-time 0.01)

(eval-when-compile
    (require 'use-package))

(require 'bind-key)  ; Required for :bind in use-package
#+END_SRC

** exec-path-from-shell
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
   :if (memq window-system '(mac ns))
   :demand t
   :config
   (progn (exec-path-from-shell-initialize)))
#+END_SRC
* Sane general behaviour

These are mostly to get the base appearance / behaviour of Emacs close to
what I'm used to from vim.

Some of this would not be necessary if I only used GUI Emacs. If I can work out
how to manage several projects in Emacs whilst keeping good separation between
them, I might be able to drop terminal support. For now though, I find it
easiest to use a workflow with one or more Tmux windows per project, each using
their own Emacs instances.

** Leader map(s)
I was using evil-leader, but think I can get the functionality I care about just
by using a keymap:

Use ~md/leader-map~ for my general-purpose leader. Mode-specific leader maps
inherit from the ~md/leader-map~.

#+BEGIN_SRC emacs-lisp
  (defvar md/leader-map (make-sparse-keymap))

  (defvar md/python-mode-leader-map (make-sparse-keymap))
  (set-keymap-parent md/python-mode-leader-map md/leader-map)
#+END_SRC

** Splash screen
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t)
#+END_SRC
** Fill column
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)

(use-package fill-column-indicator
 :defer 1
 :config
 (progn
   ;; Width of the fill column rule
   (setq fci-rule-width 5)))
#+END_SRC

** Menu bar

The toolbar appears in the GUI frame. I don't want it:

#+BEGIN_SRC emacs-lisp
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
#+END_SRC

The menu bar is intrusive in terminal Emacs, so disable it. On the OS X app it
appears as any other app toolbar at the top of the screen, which is fine:

#+BEGIN_SRC emacs-lisp
  (when (not (display-graphic-p))
    (menu-bar-mode -1))
#+END_SRC

** Fontify
Some things don't fontify quick enough (eg. fic-mode). This helps to contain
that issue:

#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook 'font-lock-fontify-buffer)
#+END_SRC

** Text wrapping

Auto-wrap text.

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'prog-mode-hook 'turn-on-auto-fill)
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
#+END_SRC

** Linum / line numbers in left margin

By default, in terminal Emacs the linum margin terminates right against the
first column of the buffer. This copies the code from linum's =dynamic=
linum-format, but adds a space so there is some separation:

#+BEGIN_SRC emacs-lisp
(setq linum-format
      (lambda (line-number)
        (let ((w (length (number-to-string
                          (count-lines (point-min) (point-max))))))
          (propertize
           (format
            (concat "%" (number-to-string w) "d ")
            line-number) 'face 'linum))))

;; TODO - I thought use-package would defer the loading of this until I do "ln",
;; but "ln" doesn't work.
(use-package linum
  :defer 1
  :bind (:map md/leader-map
         ("ln" . linum-mode)))
#+END_SRC

** Highlight cursor line
#+BEGIN_SRC emacs-lisp
;; Disable this for a minute
;;(global-hl-line-mode 1)
#+END_SRC

** Default font
#+BEGIN_SRC emacs-lisp
(defun md/set-default-font ()
  (interactive)
  (if (string= system-name "mattmbp.local")
      (set-frame-font "Monaco-12:antialias=subpixel")
    (set-frame-font "Monaco-13:antialias=subpixel")))

(md/set-default-font)
#+END_SRC

When using a server with both GUI and terminal clients attached, I want them to
show their terminal/GUI-specific default fonts:

#+BEGIN_SRC emacs-lisp
(add-hook 'focus-in-hook 'md/set-default-font)
#+END_SRC

** Scroll behaviour
#+BEGIN_SRC emacs-lisp
(setq

  ;; Start scrolling when the cursor is one line away from the top/bottom.
  scroll-margin 1

  ;; If at the bottom of the file, don't allow scroll beyond that (because
  ;; there's no use in having half a screen of empty space
  scroll-conservatively 999

  ;; Only scroll one row at a time. Default behaviour is to centre the row.
  scroll-step 1)

;; Remove scrollbars (GUI only) to get extra screen space
(use-package scroll-bar
  :if (display-graphic-p)
  :demand t
  :config (scroll-bar-mode -1))
#+END_SRC

** Cursor blinking

Ensure cursor isn't blinking:
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
#+END_SRC

** Fringe
NOTE: The Fringe only displays in GUI Emacs.

#+BEGIN_SRC emacs-lisp
(defun md/fringe-mode ()
  (interactive)
  ;; Create fringe at left side of screen.
  ;; I think 8 is the minimum width needed to display flycheck markers properly.
  (fringe-mode '(8 . 0)))

;; I just want to use this for flycheck mode.
(add-hook 'prog-mode-hook 'md/fringe-mode)

#+END_SRC

** Indentation
#+BEGIN_SRC emacs-lisp
  (setq-default

   ;; Use spaces instead of tabs
   indent-tabs-mode nil

   ;; Display tab as 4 chars wide
   tab-width 4)

  ;; Emable on-the-fly indenting. TODO - read docs for this
  (electric-indent-mode 1)
#+END_SRC
** Disable the bell
#+BEGIN_SRC emacs-lisp
(setq visible-bell nil
      ring-bell-function 'ignore)
#+END_SRC

** Terminal colour fixes

Emacs can use bold fonts, but iTerm is set to display bold fonts as "bright"
colours (which is necessary to support the Solarized 16-colour palette). This
means iTerm interprets the bold Emacs colours as bright and changes their
colour (eg. from yellow to grey), which I don't want.

I'm not sure why I didn't run into this issue with vim, and this is surely not
the right fix, but it works for now:

#+BEGIN_SRC emacs-lisp
  (when (not (display-graphic-p))
    (mapc
     (lambda (face)
       ;; Same issue with underline too.
       (set-face-underline face nil (selected-frame))

       (set-face-bold face nil (selected-frame)))
     (face-list)))
#+END_SRC

** Terminal clipboard fixes

Terminal Emacs doesn't integrate with the system clipboard by default. ~xclip~
provides this behaviour in the same way that GUI Emacs has it.

#+BEGIN_SRC emacs-lisp
  (use-package xclip
    :if (not (display-graphic-p))
    :defer 1
    :config
    (progn
      (turn-on-xclip)))
#+END_SRC

** Message buffer

Increase the number of messages:

#+BEGIN_SRC emacs-lisp
(setq message-log-max 10000)
#+END_SRC
* Backups
#+BEGIN_SRC emacs-lisp
;; Backup everything to the same directory, rather than dropping
;; files all over the place
(setq backup-directory-alist
      `(("." . ,(concat (md/get-dotfiles-path) "/emacs.d.symlink/.backups"))))
#+END_SRC
* Modifier keys
** OS X

- GUI

	- LEFT ALT :: nil (ie. standard alt/option behaviour)
  - LEFT CMD :: Meta
	- RIGHT CMD :: Super (ie. standard cmd behaviour in GUI emacs)
	- RIGHT ALT :: nil (ie. standard alt/option behaviour)

- iTerm2

	- LEFT ALT :: nil (ie. standard alt/option behaviour)
  - LEFT CMD :: iTerm cmd key (so can do usual shortcuts eg. cmd-tab)
	- RIGHT CMD :: Meta
	- RIGHT ALT :: nil (ie. standard alt/option behaviour)

	- I use the right cmd key as Meta in the terminal:

    - Under the "keys" tab, set "right cmd" to send "right option", and
      "right option" to send "left option".

    - Under the "profiles" tab, set "Right option key acts as +Esc".

#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'darwin)
      (setq

       ;; Set alt/option to use its default behaviour in OS X , so I can do
       ;; eg. alt+3 to insert #. By default in Emacs this is Meta, but I find Meta more
       ;; accessible on the left cmd key.
       ns-option-modifier nil

       ;; This is the default, and seems to handle the standard cmd key
       ;; bindings, so apple cmd+c runs super+c in emacs, etc. I don't use them
       ;; much, but they might be useful sometimes.
       ns-right-command-modifier 'super

       ;; Instead of the cmd bindings (that I don't use much), use the left
       ;; cmd key for Meta bindings. This is easier to reach than the default Meta
       ;; key (which is alt).
       ns-command-modifier 'meta))
#+END_SRC
* General utils
** Odd functions

#+BEGIN_SRC emacs-lisp
  (defun md/strip-whitespace-and-save ()
    (interactive)
    (delete-trailing-whitespace)
    (save-buffer))

  (defun md/fontify-buffer ()
    "Fontify the buffer and tell me it happened."
    (interactive)
    (font-lock-fontify-buffer)
    (message "Fontified buffer"))

  (defun md/file-info ()
    (interactive)
    (message
     "%s | %s lines | %3d%% | %s"
             (buffer-file-name)
             (count-lines (point-min) (point-max))
             (/ (window-end) 0.01 (point-max))
             major-mode))

  (defun md/mode-info ()
    (interactive)
    (message
     (format
      "%s"
      (with-temp-buffer
        (let (mm result)
          (dolist (mm (sort minor-mode-list 'string<) result)
            (insert (format "%s\n" mm))
            (setq result (buffer-substring (point-min) (point-max))))
          result)))))
#+END_SRC


It's a shame that "unfill" functions aren't included by default, but they're
easy enough to implement:

#+BEGIN_SRC emacs-lisp
  (defun md/unfill-paragraph ()
    "Because I can't always wrap to 80 characters :("
    (interactive)
    (let ((fill-column most-positive-fixnum))
      (fill-paragraph)))

  (defun md/unfill-region (start end)
    (interactive "r")
    (let ((fill-column most-positive-fixnum))
      (fill-region start end)))
#+END_SRC

** Bindings
I seem to use =describe-face= a lot:
#+BEGIN_SRC emacs-lisp
(bind-key "x" 'describe-face help-map)
(bind-key "C-k" 'describe-personal-keybindings help-map)
#+END_SRC
** Settings
#+BEGIN_SRC emacs-lisp
  (setq delete-by-moving-to-trash t)
#+END_SRC
* Evil
** Base evil

- Note on md/evil-fill and unfill:

  - Ideally, I would have a binding that maps to fill / unfill /paragraphs/ in
    normal mode, but /regions/ in visual mode. Currently I'm not sure how to get
    Evil to create different md/leader-map bindings for different Evil states,
    so for now I'll just use this workaround of checking the state in the
    function:

#+BEGIN_SRC emacs-lisp
  (use-package evil
   :demand t
   :config
   (progn
     (defun md/normal-state-and-save ()
       (interactive)
       (evil-normal-state)
       (save-buffer))

     (defun md/insert-blank-line-before ()
       (interactive)
       (save-excursion
         (end-of-line)
         (open-line 1)
         (save-buffer)))

     (defun md/insert-blank-line-after ()
       (interactive)
       (save-excursion
         (evil-previous-visual-line)
         (end-of-line)
         (open-line 1)
         (save-buffer)))

     (defun md/evil-fill (&optional start end)
       (interactive
        (if (use-region-p)
            (list (region-beginning) (region-end))
          (list nil nil)))
       (if (string= evil-state "visual")
           (fill-region start end)
         (fill-paragraph)))

     (defun md/evil-unfill (&optional start end)
       (interactive
        (if (use-region-p)
            (list (region-beginning) (region-end))
          (list nil nil)))
       (if (string= evil-state "visual")
           (md/unfill-region start end)
         (md/unfill-paragraph)))

     ;; Can't work out how to properly define map bindings using ":bind"
     (bind-key "<SPC>" md/leader-map evil-normal-state-map)
     (bind-key "<SPC>" md/leader-map evil-visual-state-map)

     (bind-key "h" help-map md/leader-map)  ; I prefer <leader>h to C-h

     (bind-key "n" (lookup-key global-map (kbd "C-x n")) md/leader-map)

     (evil-mode 1))

   :bind (;; Like my vimrc, remap  ; to : and , to ;
          :map evil-motion-state-map
          (";" . evil-ex)
          ("," . evil-repeat-find-char)

          ;; Use H/L instead of ^/$
          :map evil-normal-state-map
          ("H" . move-beginning-of-line)
          ("L" . move-end-of-line)
          :map evil-visual-state-map
          ("H" . move-beginning-of-line)
          ("L" . move-end-of-line)

          ;; The equivalent of gj/gk
          :map evil-normal-state-map
          ("j" . evil-next-visual-line)
          ("k" . evil-previous-visual-line)

          ;; Leader bindings
          :map md/leader-map
          ("w" . save-buffer)
          ("W" . md/strip-whitespace-and-save)

          ("q" . md/evil-fill)
          ("Q" . md/evil-unfill)

          ;; TODO behave like vim - ie. comment the line or the selection
          ("cc" . comment-or-uncomment-region)
          ("k" . kill-buffer)

          ("ef" . eval-defun)
          ("ee" . eval-last-sexp)  ; Bound to e because I'm used to C-x e
          ("eb" . eval-buffer)
          ("er" . eval-region)
          ("ex" . md/fontify-buffer)  ; It's sort-of an eval

          ("check" . flyspell-mode)

          ("lw" . toggle-truncate-lines)

          ("i" . md/file-info)

          ;; Same as vim - insert and save
          ("o" . md/insert-blank-line-before)
          ("O" . md/insert-blank-line-after)))

#+END_SRC

** Evil surround
#+BEGIN_SRC emacs-lisp
(use-package evil-surround
 :config
 (progn
   (global-evil-surround-mode 1)))
#+END_SRC

** Easymotion
#+BEGIN_SRC emacs-lisp
(use-package ace-jump-mode

 :config
 (progn
   (setq
    ace-jump-mode-move-keys '(?f ?j ?d ?k ?s ?l ?a ?\; ?g ?h ?r ?u ?e ?i ?w ?o ?t ?y ?b ?v ?n ?c ?m ?x)
    ace-jump-mode-scope 'window  ; If scope is wider than window performance drops a lot
    ace-jump-word-mode-use-query-char))

 :bind (:map evil-normal-state-map
             ("f" . nil)
             ("f j" . evil-ace-jump-line-mode)
             ("f k" . evil-ace-jump-line-mode)
             ("f w" . evil-ace-jump-word-mode)
             ("f b" . evil-ace-jump-word-mode)
             ("f f" . evil-ace-jump-char-mode)
             ("f F" . evil-ace-jump-char-mode)
             ("f t" . evil-ace-jump-char-mode)
             ("f T" . evil-ace-jump-char-mode)))
#+END_SRC

* Key Chord
I can't just set my insert mode "jj" and "jk" bindings in the insert-mode-map,
because if I do that then "j" gets assigned as a prefix key, and I can't
actually use it to insert anything in insert mode.

#+BEGIN_SRC emacs-lisp
  (use-package key-chord
    :config
    (progn
      (setq key-chord-two-keys-delay 0.4)

      (key-chord-define evil-insert-state-map "jj" 'md/normal-state-and-save)
      (key-chord-define evil-insert-state-map "jk" 'evil-normal-state)
      (key-chord-mode 1)))
#+END_SRC

* Dired
Dired mode has a lot of features / keys that I don't care about. Start it in
evil mode, and just add in the dired bindings that I want.

#+BEGIN_SRC emacs-lisp
  (use-package dired
    :demand t
    :init
    (progn
      ;; evil-integrations.el (https://github.com/emacsmirror/evil/blob/cd005aa50ab056492752c319b5105c38c79c2fd0/evil-integration.el#L111)
      ;; makes dired-mode-map an overriding keymap, which means that the default 
      ;; dired-mode bindings take precendence over the normal-state bindings.
      ;;
      ;; There's no obvious way to undo that code, so I'm just replacing
      ;; dired-mode-map with a new keymap that has /not/ been made 'overriding'.
      (setq dired-mode-map (make-sparse-keymap))
      (evil-define-key 'normal dired-mode-map
        "q" 'quit-window
        "d" 'dired-flag-file-deletion
        "u" 'dired-unmark
        "D" 'dired-do-delete
        (kbd "RET") 'dired-find-file
        "J" 'dired-jump
        "o" 'dired-find-file-other-window
        "R" 'dired-do-rename
        "C" 'dired-do-copy
        "i" 'dired-maybe-insert-subdir
        "+" 'dired-create-directory)))
#+END_SRC

* Highlight keywords in comments

#+BEGIN_SRC emacs-lisp
(use-package fic-mode
 :defer 1
 :init
 (progn
   (add-hook 'prog-mode-hook 'fic-mode))
 :config
 (progn
   ;; NOTE: fic-mode doesn't seem to fontify the buffer, so words don't appear
   ;; highlighted unless either something else fontifies the buffer, or we do it
   ;; manually. Would like to improve this.
   ;;
   ;; FIX: fic-mode doesn't seem to identify words on the same line as my cursor
   ;; when I change theme and then fontify the buffer. All other lines seem fine.

   (setq fic-highlighted-words
         '("TODO" "FIX" "FIXME" "BUG" "WARN" "WARNING" "HACK" "NOTE" "ERROR" "MATT"))

   ;; By default this includes font-lock-string-face, but I don't want strings to
   ;; have these words formatted.
   (setq fic-activated-faces '(font-lock-doc-face font-lock-comment-face))))
#+END_SRC

I can use this with grep/ag to quickly find the todo comments:
#+BEGIN_SRC emacs-lisp
  (defun md/insert-todo-regexp ()
    (interactive)
    (insert "TODO|FIX|FIXME|BUG|WARN|HACK|ERROR"))
#+END_SRC

* Helm
** Base helm
- [ ] NOTE - describe-function and describe-variable don't use helm until helm
  has been configured. Work out how to load helm when they're called.

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :defer 5
    :config
    (progn
      ;; Putting these here to avoid byte-compiled issue where helm-map isn't defined.

      ;; This lets me quickly ag/grep for "todo" comments using the same
      ;; ag/grep functions that I usually do.
      (bind-key "C-c C-t" 'md/insert-todo-regexp helm-map)
      ;;("<tab>" . helm-execute-persistent-action)
      ;;("C-z" . helm-select-action)

      (helm-mode 1)
      (helm-autoresize-mode 0))
    :bind (([remap find-file] . helm-find-files)  ; Remember - this also opens URLs!
           ([remap occur] . helm-occur)
           ([remap dabbrev-expand] . helm-dabbrev)
           ([remap list-buffers] . helm-buffers-list)
           ("M-x" . helm-M-x)
           ("C-x b" . helm-buffers-list)
           ("C-x p" . helm-mini)

           :map lisp-interaction-mode-map
           ([remap completion-at-point] . helm-lisp-completion)

           :map emacs-lisp-mode-map
           ([remap completion-at-point] . helm-lisp-completion)

           :map md/leader-map
           ("b" . helm-buffers-list)
           ("f" . helm-find-files)
           ("x" . helm-M-x)
           ("p" . helm-mini)

           :map help-map
           ("X" . helm-colors)))

#+END_SRC

** Addons
#+BEGIN_SRC emacs-lisp
  (use-package helm-ag
    :defer 5
    :config
    (defun md/ag ()
      "Run helm-do-ag on the default-directory"
      (interactive)
      (helm-do-ag default-directory))
    :bind (:map md/leader-map
                ("ag" . md/ag)))
#+END_SRC

* help-fns+
This package provides ~describe-keymap~ to M-k in the help-map, which is
handy. It does some other things too (TODO - read docs).

#+BEGIN_SRC emacs-lisp
(use-package help-fns+ :defer 1)
#+END_SRC

* Help mode
I prefer to use vi keys to navigate help-mode:

#+BEGIN_SRC emacs-lisp
  (evil-set-initial-state 'help-mode 'normal)
  (evil-define-key 'normal help-mode-map
    "q" 'quit-window
    (kbd "C-i") 'help-go-forward
    (kbd "C-o") 'help-go-back
    (kbd "<RET>") 'help-follow-symbol)
#+END_SRC

* Which-key

[[https://github.com/justbur/emacs-which-key][which-key]] displays available bindings for the current prefix, which makes it
easier to discover features / work out where I am:

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :defer 2
    :config
    (progn
      (setq which-key-idle-delay 0.5
            which-key-max-description-length 30)

      ;; Alow show evil motion keys. This is an experimental feature.
      (setq which-key-allow-evil-operators t
            which-key-show-operator-state-maps t)
      (which-key-mode)))
#+END_SRC

* Parentheses
Basic paren matching is built in. I preferred these settings at one point,
although I don't remember exactly what the difference is:

#+BEGIN_SRC emacs-lisp
  (use-package paren
   :defer 1
   :init (progn
          (add-hook 'prog-mode-hook 'show-paren-mode))
   :config
   (progn
     (setq show-paren-style 'parenthesis
           blink-matching-paren nil
           blink-matching-paren-on-screen nil)))
#+END_SRC

* Elscreen

Elscreen provides "tabs" that let me sort of arrange windows how I did it in
vim. They're not ideal though, because the tabs either appear in several places
on the screen, or nowhere.

#+BEGIN_SRC emacs-lisp
  (use-package elscreen
   :defer 1
   :config
   (progn
     (defun md/elscreen-hide-tabs ()
       (interactive)
       ;; This is how elscreen hides tabs in (elscreen-toggle-display-tab)
       (setq elscreen-display-tab nil)
       (elscreen-notify-screen-modification 'force))

     (md/elscreen-hide-tabs)))
#+END_SRC

* Splitscreen
#+BEGIN_SRC emacs-lisp
(setq md/splitscreen-path (concat (md/get-dotfiles-path) "/splitscreen/"))

;; NOTE - for some reason this doesn't seem to load with "defer"
(use-package splitscreen
 :load-path md/splitscreen-path
 :demand t
 :config
 (progn
   (splitscreen-mode)))
#+END_SRC
* Org
#+BEGIN_SRC emacs-lisp
    (use-package org
     :defer 5
     :config
     (progn

       (defun md/org-timestamp-time-inactive-no-confirm ()
         (interactive)
         (org-insert-time-stamp (current-time) t t))

       (defun md/org-timestamp-date-inactive-no-confirm ()
         (interactive)
         (org-insert-time-stamp (current-time) nil t))

       (defun md/org-insert-link-from-paste ()
         (interactive)
         (org-insert-link nil
                          (with-temp-buffer
                            (evil-paste-after nil)
                            (delete-trailing-whitespace)
                            (buffer-string))))

       (defun md/org-hook ()
         ;; Change tab widths to fit headline indents
         (setq tab-width 2
               evil-shift-width 2)

         ;; Disable in-buffer line numbers and the colour column, as both decrease
         ;; org-mode / outline performance significantly on large files.
         (linum-mode 0)
         (fci-mode 0)

         ;; Also disable the row and column numbers in the modeline. Seems you have to set
         ;; these manually to make them buffer-local, unlike the above functions - TODO
         ;; is this a bad thing?
         (setq-local line-number-mode nil)
         (setq-local column-number-mode nil)

         ;; Also don't highlight the current line. For some reason this rquires making
         ;; global-hl-line-mode buffer-local.
         (make-variable-buffer-local 'global-hl-line-mode)
         (setq-local global-hl-line-mode nil))

       (define-minor-mode md/evil-org-mode
         "Buffer local minor mode for evil-org"
         :init-value nil
         :lighter " EvilOrg"
         :keymap (make-sparse-keymap) ; defines md/evil-org-mode-map
         :group 'md/evil-org)

       ;; NOTE - I don't think the use-package ":bind" arg allows defining evil keys
       ;; for a specific evil-mode/map combination.

       ;; Normal state shortcuts
       (evil-define-key 'normal md/evil-org-mode-map
         "gk" 'outline-previous-visible-heading
         "gj" 'outline-next-visible-heading
         "H" 'org-beginning-of-line
         "L" 'org-end-of-line
         "$" 'org-end-of-line
         "^" 'org-beginning-of-line
         "-" 'org-cycle-list-bullet
         (kbd "RET") 'org-cycle
         (kbd "TAB") 'org-cycle)

       ;; Normal & insert state shortcuts.
       (mapc (lambda (state)
               (evil-define-key state md/evil-org-mode-map
                 (kbd "M-l") 'org-metaright
                 (kbd "M-h") 'org-metaleft
                 (kbd "M-k") 'org-metaup
                 (kbd "M-j") 'org-metadown
                 (kbd "M-L") 'org-shiftmetaright
                 (kbd "M-H") 'org-shiftmetaleft
                 (kbd "M-K") 'org-shiftmetaup
                 (kbd "M-J") 'org-shiftmetadown
                 ))
             '(normal insert))

       ;; I don't like the default org-agenda bindings - there are far more
       ;; bindings/features than I should have to think about, and I usually try to
       ;; navigate using evil bindings (and eg. accidentally hit "j" and bring up
       ;; the calendar etc).
       ;;
       ;; Instead, open org-agenda in evil-normal-mode, with a couple of the useful
       ;; bindings copied directly from emacs-mode.
       (define-minor-mode md/evil-org-agenda-mode
         "Buffer local minor mode for evil-org-agenda"
         :init-value nil
         :lighter " EvilOrgAgenda"
         :keymap (make-sparse-keymap) ; defines md/evil-org-agenda-mode-map
         :group 'md/evil-org-agenda)

       (evil-set-initial-state 'org-agenda-mode 'normal)

       (evil-define-key 'normal md/evil-org-agenda-mode-map
         ;; j / k
         (kbd "j") 'org-agenda-next-line
         (kbd "n") 'org-agenda-next-line
         (kbd "C-n") 'org-agenda-next-line
         (kbd "k") 'org-agenda-previous-line
         (kbd "p") 'org-agenda-previous-line
         (kbd "C-p") 'org-agenda-previous-line

         (kbd "q") 'org-agenda-quit
         (kbd "r") 'org-agenda-redo  ; Recalculate the agenda
         (kbd "v") 'org-agenda-view-mode-dispatch  ; Alter the view
         (kbd "|") 'org-agenda-filter-remove-all  ; Remove existing filters
         (kbd "=") 'org-agenda-filter-by-regexp  ; Search
         (kbd "/") 'org-agenda-filter-by-tag  ; Tag filter
         (kbd "^") 'org-agenda-filter-by-top-headline  ; Show other items with same
                                            ; headline as current
         (kbd "A") 'org-agenda-append-agenda)  ; Add another agenda

       (add-hook 'org-mode-hook 'md/org-hook)
       (add-hook 'org-mode-hook 'md/evil-org-mode)
       (add-hook 'org-agenda-mode-hook 'md/evil-org-agenda-mode)

       (setq org-agenda-restore-windows-after-quit t

             ;; Add timestamp when set task as closed
             org-log-done 'time

             ;; Fontify inline code
             org-src-fontify-natively t

             ;; When editing code, I don't want to open another window. This
             ;; just makes the screen tidier.
             org-src-window-setup 'current-window

             ;; tab / indentation is the main reason I would use C-' so prevent it if possible
             org-src-tab-acts-natively t

             ;; Colour the whole headline
             org-level-color-stars-only nil

             ;; Try to prevent accidentally editing invisible lines
             org-catch-invisible-edits 'show-and-error

             org-adapt-indentation nil

             org-clock-out-remove-zero-time-clocks t

             ;; If press M-RET I want a new line, not to split the line
             org-M-RET-may-split-line nil

             ;; Default to using my CSS theme for html exports
             org-html-head-extra "
            <link id='generic-css-dark' rel='stylesheet' type='text/css'
                  href='https://mattduck.github.io/generic-css/css/generic-dark.css'>
            <link id='generic-css-light' rel='stylesheet' type='text/css'
                  href='https://mattduck.github.io/generic-css/css/generic-light.css'>
            <script type='text/javascript'src='https://mattduck.github.io/generic-css/js/generic-css.js'></script>"

             org-export-headline-levels 6
             org-export-with-section-numbers 4)


       ;; Putting these here to avoid byte-compiled issue where org-mode-map isn't defined.
       (bind-key "C-c d" 'md/org-timestamp-date-inactive-no-confirm org-mode-map)
       (bind-key "C-c t" 'md/org-timestamp-time-inactive-no-confirm org-mode-map)
       (bind-key "C-c l" 'md/org-insert-link-from-paste org-mode-map))
     :bind (:map global-map
           ("C-c a" . org-agenda)))

#+END_SRC
* Modeline
** General modeline
#+BEGIN_SRC emacs-lisp
(line-number-mode 1)
(column-number-mode 1)
#+END_SRC

** Powerline
#+BEGIN_SRC emacs-lisp
(use-package powerline
 :defer 1
 :config
 (progn
   (defun md/powerline-setup ()
     (interactive)
     (require 'flycheck)
     (setq-default mode-line-format
                   '("%e"
                     (:eval
                      (let* ((active (powerline-selected-window-active))
                             (mode-line (if active 'mode-line 'mode-line-inactive))
                             (face1 (if active 'powerline-active1 'powerline-inactive1))
                             (face2 (if active 'powerline-active2 'powerline-inactive2))
                             (separator-left (intern (format "powerline-%s-%s"
                                                             (powerline-current-separator)
                                                             (car powerline-default-separator-dir))))
                             (separator-right (intern (format "powerline-%s-%s"
                                                              (powerline-current-separator)
                                                              (cdr powerline-default-separator-dir))))

                             (lhs (list (powerline-raw evil-mode-line-tag face2 'l)
                                        (funcall separator-left face2 face1)
                                        (powerline-raw (format "*%s* " (powerline-major-mode)) face1 'l)
                                        (funcall separator-left face1 mode-line)
                                        (if (and (boundp 'projectile-mode) projectile-mode)
                                            (powerline-raw (concat (projectile-project-name) "::%b") 'l)
                                          (powerline-raw "%b" mode-line 'l))

                                        (when (buffer-modified-p)
                                          (powerline-raw "+" mode-line 'l))
                                        (when buffer-read-only
                                          (powerline-raw "[RO]" mode-line 'l))
                                        (when (buffer-narrowed-p)
                                          (powerline-raw "  Narrow" mode-line 'l))
                                        (when (and active (fboundp 'org-clocking-p) (org-clocking-p))
                                          (powerline-raw
                                           (propertize
                                            (format "  %s "
                                                    (if (> (length org-mode-line-string) 50)
                                                        (format "%s..." (string-trim (substring org-mode-line-string 0 50)))
                                                      org-mode-line-string))
                                            'face nil)
                                           mode-line 'l))))

                             (rhs (list (funcall separator-right mode-line face1)
                                        (powerline-vc face1 'r)
                                        (when (or line-number-mode column-number-mode)
                                          (cond ((and line-number-mode
                                                      column-number-mode)
                                                 (powerline-raw "%5l:%2c" face2 'r))
                                                (line-number-mode
                                                 (powerline-raw "%5l" face2 'r))
                                                (column-number-mode
                                                 (powerline-raw ":%2c" face2 'r))))


                                        ;; TODO: change colour when err/warn, and
                                        ;; list line of first error
                                        ;; (when flycheck-mode
                                        ;;   (powerline-raw (format "%6s" (flycheck-mode-line-status-text)) 'error 'r))
                                        (when (and active flycheck-mode (flycheck-has-current-errors-p))
                                          (powerline-raw
                                           (format " [line:%s (%s)] "
                                                   ;; Line of first err
                                                   (save-excursion
                                                     (flycheck-first-error)
                                                     (+ 1 (count-lines (point-min) (point))))
                                                   ;; Total lines
                                                   (length flycheck-current-errors))

                                           ;; Face
                                           (cond ((flycheck-has-current-errors-p 'error)
                                                  'md/modeline-flycheck-error)
                                                 ((flycheck-has-current-errors-p 'warning)
                                                  'md/modeline-flycheck-warning))
                                           'r))



                                        ))
                             )
                        (concat (powerline-render lhs)
                                (powerline-fill mode-line (powerline-width rhs))
                                (powerline-render rhs)))))))

   (defun md/powerline-reset ()
     (interactive)
     (setq mode-line-format (md/powerline-setup))
     (solarized-load-theme))

   (md/powerline-setup)
   (md/powerline-reset)))
#+END_SRC
* List unbound keys

This is handy sometimes - it provides ~free-keys~, which lists unbound keys.

#+BEGIN_SRC emacs-lisp
  (use-package free-keys
    :defer 10
    :config
      (progn
        (bind-key "@" 'free-keys help-map)))
#+END_SRC

* Autocompletion

Company seems to work nicely without much configuration.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :defer 2
    :config
    (progn
      ;; Bind here rather than in ":bind" to avoid complaints about
      ;; company-mode-map not existing.
      (bind-key "C-n" 'company-select-next company-active-map)
      (bind-key "C-p" 'company-select-previous company-active-map)

      ;; By default this performs company-complete-common, but I don't
      ;; think I'll want to use that
      (bind-key "TAB" 'company-complete-selection company-active-map)

      (bind-key "C-n" 'company-complete evil-insert-state-map)

      (global-company-mode)))
#+END_SRC

* Syntax checking
#+BEGIN_SRC emacs-lisp
(use-package flycheck
 :config
 :init
 (progn
   (add-hook 'prog-mode-hook 'flycheck-mode))
 (progn
   (defface md/modeline-flycheck-error '((t (:inherit 'error))) "")
   (defface md/modeline-flycheck-warning '((t (:inherit 'warning))) "")

   (setq flycheck-flake8rc ".config/flake8"
         flycheck-highlighting-mode 'symbols

         ;; defaults to 0.9, which is too slow
         flycheck-display-errors-delay 0.1

         ;; There's a short delay when flycheck runs, which causes the modeline to change
         ;; its format (or in my custom powerline stuff, to disappear briefly). It's
         ;; super annoying if this happens at random points during editing, so change it
         ;; to only happen on save (and when enabling the mode). This is quite similar to how
         ;; I had it setup in vim.
         flycheck-check-syntax-automatically '(save mode-enabled)

         flycheck-mode-line-prefix nil))
 :bind (:map md/leader-map
        ;; S prefix, ie. "syntax"
        ("s <RET>" . flycheck-mode)
        ("sl" . flycheck-list-errors)
        ("sn" . flycheck-next-error)
        ("sj" . flycheck-next-error)
        ("sp" . flycheck-previous-error)
        ("sk" . flycheck-previous-error)))

#+END_SRC
* Projectile
** Base projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
 :config
 (progn
   (setq projectile-file-exists-local-cache-expire (* 10 60)
         projectile-enable-caching t)
   (projectile-global-mode))
 :bind (:map md/leader-map
       ("jk" . projectile-kill-buffers)))
#+END_SRC

** Helm
#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :init (progn
            ;; This has to be set before loading helm-projectile
            (setq helm-projectile-fuzzy-match nil))
    :bind (:map md/leader-map
                ("jj" . helm-projectile-switch-project)
                ("jag" . helm-projectile-ag)
                ("jb" . helm-projectile-switch-to-buffer)

                ;; TODO - proper binding for invalidating cache
                ("jf" . helm-projectile-find-file)))
#+END_SRC

* Git
** git-gutter
#+BEGIN_SRC emacs-lisp

  (use-package git-gutter
   :init
   (progn
     (defun md/set-sensible-column ()
       "Unless file is too big, either use git-gutter mode (when in
  git dir) or linum mode"
       (interactive)
       (when (< (count-lines (point-min) (point-max)) 2000)
         (if (string= "git" (downcase (format "%s" (vc-backend
                                                    (buffer-file-name
                                                     (current-buffer))))))
             (git-gutter-mode 1)
           (linum-mode 1))))
     (add-hook 'find-file-hook 'md/set-sensible-column))
   :config
   (progn
     (setq git-gutter:ask-p nil  ; Don't ask for confirmation of gadd
           git-gutter:modified-sign "~"
           git-gutter:added-sign "+"
           git-gutter:deleted-sign "-"

           ;; This ensures the separator is always displayed
           git-gutter:unchanged-sign " "
           git-gutter:always-show-separator t

           ;; Without this, there's no space between the git-gutter column and the code.
           git-gutter:separator-sign " "))
   :bind (:map md/leader-map
         ("g <RET>" . git-gutter-mode)
         ("gk" . git-gutter:previous-hunk)
         ("gp" . git-gutter:previous-hunk)
         ("gj" . git-gutter:next-hunk)
         ("gn" . git-gutter:next-hunk)
         ("gadd" . git-gutter:stage-hunk)
         ("grev" . git-gutter:revert-hunk)))

#+END_SRC

** magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
   :config
   (progn
     (evil-set-initial-state 'magit-blame-mode 'normal)
     (evil-set-initial-state 'magit-revision-mode 'normal)

     ;; I don't know why, but by default I can't get magit-blame to adhere to my
     ;; normal-mode map below, even though Evil says I'm in normal mode. Explicitly
     ;; calling evil-normal-state fixes it.
     (add-hook 'magit-blame-mode-hook 'evil-normal-state)
     (evil-define-key 'normal magit-blame-mode-map
       (kbd "<RET>") 'magit-show-commit
       "q" 'magit-blame-quit
       "gj" 'magit-blame-next-chunk
       "gn" 'magit-blame-next-chunk
       "gk" 'magit-blame-previous-chunk
       "gp" 'magit-blame-previous-chunk)

     (add-hook 'magit-revision-mode-hook 'evil-normal-state)
     (evil-define-key 'normal magit-revision-mode-map
       (kbd "<RET>") 'magit-diff-visit-file
       "q" 'magit-mode-bury-buffer))  ;; This quits

   :bind (:map md/leader-map
         ("gmag" . magit-dispatch-popup)
         ("gblame" . magit-blame)

         ;; NOTE - this doesn't play nicely with mode-line:
         ;; - https://github.com/magit/magit/blob/master/Documentation/magit.org#the-mode-line-information-isnt-always-up-to-date
         ;; - https://github.com/syl20bnr/spacemacs/issues/2172
         ("gco" . magit-checkout)

         ("gdiff" . magit-ediff-popup)))

#+END_SRC

* Web mode
This makes working with HTML/CSS/JS files much nicer. TODO - read documentation
/ configure.

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :defer 1)

#+END_SRC

* Restclient
For 80% of use-cases, I think [[https://github.com/pashky/restclient.el][restclient]] will be more convenient than Postman.

#+BEGIN_SRC emacs-lisp
  (use-package restclient
    :defer 1
    :mode (("\\.http\\'" . restclient-mode)))

  (use-package restclient-helm :defer 5)
#+END_SRC

Add company completion for restclient:

#+BEGIN_SRC emacs-lisp
  (use-package company-restclient
    :config
    (progn
        (add-to-list 'company-backends 'company-restclient)))
#+END_SRC

#+BEGIN_EXAMPLE
POST https://httpbin.org/post

This is the body
#+END_EXAMPLE

* Ediff
#+BEGIN_SRC emacs-lisp
(use-package ediff
 :defer 1
 :config
 (progn
   ;; TODO - I want ediff to have evil-like bindings
   (setq ediff-split-window-function 'split-window-horizontally)))

#+END_SRC
* Solarized

#+BEGIN_SRC emacs-lisp
  (use-package color-theme-solarized
   :demand t
   :ensure nil
   :load-path "non-elpa/color-theme-solarized"
   :config
   (progn
     (add-to-list 'custom-theme-load-path "non-elpa/color-theme-solarized")

     ;; Necessary on v24.4 to display accurate Solarized colors, due to Emacs bug
     ;; #8402. v24.3 didn't set ns-use-sgrb-colorspace.
     (setq ns-use-srgb-colorspace nil
           solarized-broken-srgb t)

     ;; See heading on terminal colour fixes near top of file
     (when (not (display-graphic-p))
       (setq solarized-bold nil))

     (load-theme 'solarized t)  ; Defaults to light
     (solarized-enable-theme 'dark))

   :bind (:map md/leader-map
          ("sol" . solarized-toggle-theme-mode)
          ("chl" . solarized-toggle-comment-visibility)))
#+END_SRC

* Colour hex values
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :defer 1
    :config
    (progn
       (add-hook 'css-mode-hook 'rainbow-mode)
       (add-hook 'help-mode-hook 'rainbow-mode)
       (add-hook 'html-mode-hook 'rainbow-mode)
       (add-hook 'prog-mode-hook 'rainbow-mode)))
#+END_SRC

* Markdown

AFAICT markdown syntax highlighting isn't provided by default. [[https://github.com/jrblevin/markdown-mode][Markdown mode]]
includes highlighting, plus some extra features like inserting elements and
compiling. It also includes ~gfm-mode~ for Github-flavoured markdown.

NOTE - compiling requires ~markdown~ to be installed.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode)))
#+END_SRC

* Dotfiles

Equivalent of my "ve" binding that would edit my vimrc:

#+BEGIN_SRC emacs-lisp
  (defun md/dotfiles-edit ()
    (interactive)
    (find-file (concat (md/get-dotfiles-path) "/emacs.d.symlink/init.org")))

  (bind-key "ve" 'md/dotfiles-edit md/leader-map)
#+END_SRC

* Python

Elpy combines a few different Python packages / features.

#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :defer 1  ;; Defer this just because it's slow to load.
    :config
    (progn
      (elpy-enable)

      ;; - Remove elpy-module-flymake because I already have flymake configured.
      ;; - Remove elpy-module-highlight indentation because it's distracting.
      (setq elpy-modules (list
                          'elpy-module-sane-defaults
                          'elpy-module-company
                          'elpy-module-eldoc
                          'elpy-module-pyvenv
                          'elpy-module-yasnippet))

      (setq elpy-rpc-backend "jedi")

      ;; Setup leader map for python
      (evil-define-key 'normal python-mode-map
        (kbd "SPC") md/python-mode-leader-map
        "gk" 'python-nav-backward-defun
        "gj" 'python-nav-forward-defun)

      (evil-define-key 'insert elpy-mode-map (kbd "C-n") 'elpy-company-backend)

      (if (string= major-mode "python-mode")
        (progn
          ;; If I've opened a Python file make sure everything loads properly
          ;; on this buffer.
          (python-mode)
          (elpy-mode 1))))

    :bind (:map md/python-mode-leader-map
                ("SPC v" . pyvenv-workon)
                ("SPC V" . pyvenv-activate)
                ("SPC f" . elpy-format-code)
                ("SPC t" . elpy-test)
                ("SPC d" . elpy-doc)
                ("SPC g" . elpy-goto-definition-other-window)
                ("SPC r" . elpy-multiedit-python-symbol-at-point)))

#+END_SRC

* Golang
#+BEGIN_SRC emacs-lisp
  (use-package go-mode)
#+END_SRC

* Yaml
Not sure if this provides anything beyond syntax highlighting, but that's enough
for now:

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode)
#+END_SRC

* Terraform
Not sure if this provides anything beyond syntax highlighting, but that's enough
for now:

#+BEGIN_SRC emacs-lisp
  (use-package terraform-mode)
#+END_SRC

* Profile Emacs startup

Running ~esup~ will start Emacs and profile the startup time. To get GUI on par
w/terminal, I can disable exec-path-from-shell.

#+BEGIN_SRC emacs-lisp
(use-package esup
  :defer 5)
#+END_SRC

* Teardown

Profiling. This number comes out slightly different to ~(emacs-init-time)~

#+BEGIN_SRC emacs-lisp
(defconst md/emacs-init-end (current-time))

(defconst md/emacs-boot-time (float-time (time-subtract md/emacs-init-end md/emacs-init-start)))
(message (format "md/emacs-boot-time: %s" md/emacs-boot-time))

#+END_SRC

Close paren for the wrapping ~let~:

#+BEGIN_SRC emacs-lisp
)
#+END_SRC

* TODO
- [ ] tab key not inserting tabs in evil?
  - it aligns but doesn't insert tab, not sure if this is behaviour i want. It
    runs indent-for-tab-command. Try it for a while.
- [ ] savehist-mode.
- [ ] indents.
- [ ] read electric-indent docs.
- [ ] does electric-indent need different configuration in python? I used to
  have something for this.
- [ ] undo tree?
- [ ] info / other help modes - use vi keys to navigate?
- [ ] how to preserve binding in map?
  - Eg. I want to use normal mode for some magit modes, but I generally want to retain
    the behaviour of RET. This is true for help modes too.
- [ ] jumping to definitions
- [ ] finding uses of functions
- [ ] ediff / git diff
- [ ] colour emacs state in modeline
- [ ] checkout avy - improvement to acejump?
- [ ] debugger
- [ ] folding
- [ ] autocomplete
- [ ] spellcheck?
- [ ] checkout slime
- [ ] jumping forward/back to markers including between files
- [ ] stop littering # backup files
- [ ] startup time?
  - bottleneck is down to ~(package-initialize)~ and evil startup.
  - elpy is slow.
- [ ] https://github.com/emacs-tw/awesome-emacs
  - [ ] multi cursor?
- [ ] gk/gj for next/prev functions
- [ ] how to create different md/leader-map bindings for different evil states
  and/or modes?
- [ ] why can't I select something and then paste when in visual mode? This used
  to work
  - [2016-07-08 Fri] seem to work now?
- [ ] go mode
- [ ] python development / elpy
  - [ ] open documentation
  - [ ] run tests
  - [ ] refactoring
- [ ] the elpy flycheck colours aren't bad, and work in terminal - consider
  using them for full flycheck.
- [ ] eldoc mode?
- [ ] check company addons
  - there's one for restclient.
- [ ] helm-projectile-find-file is worse than ctrlp
  - slower
  - no ag ignore
- [ ] how does flyspell work? doesn't seem to show anything?
- [ ] git gutter mode should be by default for every opened file
- [ ] want to open file/mark in github
