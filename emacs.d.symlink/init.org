#+COMMENT (org-babel-tangle nil "init.el")
#+TITLE init.org
* Initial Setup

I'm using org-mode to structure my configuration. Inspired by [[https://github.com/sachac/.emacs.d][Sacha Chua]] and [[https://github.com/eschulte/emacs24-starter-kit/][Emacs Starter Kit]].

** GC
Increase the GC threshold to 100MB. This decreases Emacs load time by
~600ms (at least, when I'm not using =use-package=). This gets reset at the end
of the file.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 100000000)
#+END_SRC

** Dotfiles

I use this to refer to this directory / file:

#+BEGIN_SRC emacs-lisp
(defun md/get-dotfiles-path ()
  (or
    (getenv "DOTFILES")
    (concat (expand-file-name "~") "/dotfiles")))
#+END_SRC

** Emacs Package setup
#+BEGIN_SRC emacs-lisp
;; NOTE - this is old, maybe I can remove it
(defun md/refresh-packages ()
  (interactive)
  (when (not package-archive-contents)
    (package-refresh-contents)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(package-initialize)

(setq package-archives
      '(("gnu" . "http://elpa.gnu.org/packages/")
        ("marmalade" . "http://marmalade-repo.org/packages/")
        ("melpa" . "http://melpa.milkbox.net/packages/")
        ("org" . "http://orgmode.org/elpa/")))

(setq load-prefer-newer t)  ; new in v24.4
#+END_SRC

** Custom file

#+BEGIN_SRC emacs-lisp
(setq custom-file (concat (md/get-dotfiles-path) "/emacs.d.symlink/custom.el"))
(load custom-file 'noerror)
#+END_SRC

** use-package setup

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
    (package-install 'use-package))
(eval-when-compile
    (require 'use-package))
(require 'bind-key)  ; Required for :bind in use-package
(setq use-package-always-ensure nil
      use-package-verbose t)
#+END_SRC

** exec-path-from-shell
#+BEGIN_SRC emacs-lisp
(use-package
 exec-path-from-shell
 :demand t
 :config
 (progn
  (when (memq window-system '(mac ns))
    (exec-path-from-shell-initialize))))
#+END_SRC
* Sane general behaviour

These are mostly to get the base appearance / behaviour of Emacs close to
what I'm used to from vim.

Some of this would not be necessary if I only used GUI Emacs. If I can work out
how to manage several projects in Emacs whilst keeping good separation between
them, I might be able to drop terminal support. For now though, I find it
easiest to use a workflow with one or more Tmux panes per project, each using
their own Emacs instances.

** Splash screen
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t)
#+END_SRC
** Fill column
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)

(use-package
 fill-column-indicator
 :config
 (progn
   ;; Width of the fill column rule
   (setq fci-rule-width 5)))
#+END_SRC

** Menu bar
By default, terminal emacs displays a menu bar. I don't use it, so remove
it. This doesn't affect the OS X app.

Also disable the toolbar - I'm not sure in what circumstances this is displayed,
but I don't want it.

#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
#+END_SRC

** Fontify
Some things don't fontify quick enough (eg. fic-mode). This helps to contain
that issue:

#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook 'font-lock-fontify-buffer)
#+END_SRC

** Text wrapping

Auto-wrap text.

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'prog-mode-hook 'turn-on-auto-fill)
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
#+END_SRC

** Linum / line numbers in left margin
By default, in terminal Emacs the linum margin terminates right against the
first column of the buffer. This copies the code from linum's =dynamic=
linum-format, but adds a space so there is some separation:
#+BEGIN_SRC emacs-lisp
(setq linum-format
      (lambda (line-number)
        (let ((w (length (number-to-string
                          (count-lines (point-min) (point-max))))))
          (propertize
           (format
            (concat "%" (number-to-string w) "d ")
            line-number) 'face 'linum))))

(use-package
  linum-mode
  :bind (:map md/leader-map
         ("ln" . linum-mode)))

;; TODO - I thought use-package would defer the loading of this until I do "ln",
;; but "lb" doesn't work.  
(require 'linum)
#+END_SRC

** Highlight cursor line
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode 1)
#+END_SRC

** Default font
#+BEGIN_SRC emacs-lisp
(defun md/set-default-font ()
  (interactive)
  (if (string= system-name "mattmbp.local")
      (set-frame-font "Monaco-12:antialias=subpixel")
    (set-frame-font "Monaco-13:antialias=subpixel")))

(md/set-default-font)
#+END_SRC

When using a server with both GUI and terminal clients attached, I want them to
show their terminal/GUI-specific default fonts:

#+BEGIN_SRC emacs-lisp
(add-hook 'focus-in-hook 'md/set-default-font)
#+END_SRC

** Scroll behaviour
#+BEGIN_SRC emacs-lisp
(setq

  ;; Start scrolling when the cursor is one line away from the top/bottom.
  scroll-margin 1

  ;; If at the bottom of the file, don't allow scroll beyond that (because
  ;; there's no use in having half a screen of empty space
  scroll-conservatively 999

  ;; Only scroll one row at a time. Default behaviour is to centre the row.
  scroll-step 1)

;; Remove scrollbars (GUI only) to get extra screen space
(require 'scroll-bar)
(scroll-bar-mode -1)
#+END_SRC

** Cursor blinking

Ensure cursor isn't blinking:
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
#+END_SRC

** Fringe
NOTE: The Fringe only displays in GUI Emacs.

#+BEGIN_SRC emacs-lisp
(defun md/fringe-mode ()
  (interactive)
  ;; Create fringe at left side of screen.
  ;; I think 8 is the minimum width needed to display flycheck markers properly.
  (fringe-mode '(8 . 0)))

;; I just want to use this for flycheck mode.
(add-hook 'prog-mode-hook 'md/fringe-mode)

#+END_SRC

** Indentation
#+BEGIN_SRC emacs-lisp
  (setq-default

   ;; Use spaces instead of tabs
   indent-tabs-mode nil

   ;; Display tab as 4 chars wide
   tab-width 4)

  ;; Emable on-the-fly indenting. TODO - read docs for this
  (electric-indent-mode 1)
#+END_SRC
** Disable the bell
#+BEGIN_SRC emacs-lisp
(setq visible-bell nil
      ring-bell-function 'ignore)
#+END_SRC

** Terminal colour fixes

Emacs can use bold fonts, but iTerm is set to display bold fonts as "bright"
colours (which is necessary to support the Solarized 16-colour palette). This
means iTerm interprets the bold Emacs colours as bright and changes their
colour (eg. from yellow to grey), which I don't want.

I'm not sure why I didn't run into this issue with vim, and this is surely not
the right fix, but it works for now:

#+BEGIN_SRC emacs-lisp
  (when (not (display-graphic-p))
    (mapc
     (lambda (face)
       (set-face-bold face nil (selected-frame)))
     (face-list)))
#+END_SRC

** Terminal clipboard fixes

Terminal Emacs doesn't integrate with the system clipboard by default. ~xclip~
provides this behaviour in the same way that GUI Emacs has it.

#+BEGIN_SRC emacs-lisp
  (use-package xclip
    :config
    (progn
      (turn-on-xclip)))
  (require 'xclip)
#+END_SRC

* Backups
#+BEGIN_SRC emacs-lisp
;; Backup everything to the same directory, rather than dropping
;; files all over the place
(setq backup-directory-alist
      `(("." . ,(concat (md/get-dotfiles-path) "/emacs.d.symlink/.backups"))))
#+END_SRC
* Modifier keys
** OS X

- GUI

	- LEFT ALT :: nil (ie. standard alt/option behaviour)
  - LEFT CMD :: Meta
	- RIGHT CMD :: Super (ie. standard cmd behaviour in GUI emacs)
	- RIGHT ALT :: nil (ie. standard alt/option behaviour)

- iTerm2

	- LEFT ALT :: nil (ie. standard alt/option behaviour)
  - LEFT CMD :: iTerm cmd key (so can do usual shortcuts eg. cmd-tab)
	- RIGHT CMD :: Meta
	- RIGHT ALT :: nil (ie. standard alt/option behaviour)

	- I use the right cmd key as Meta in the terminal:

    - Under the "keys" tab, set "right cmd" to send "right option", and
      "right option" to send "left option".

    - Under the "profiles" tab, set "Right option key acts as +Esc".

#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'darwin)
      (setq

       ;; Set alt/option to use its default behaviour in OS X , so I can do
       ;; eg. alt+3 to insert #. By default in Emacs this is Meta, but I find Meta more
       ;; accessible on the left cmd key.
       ns-option-modifier nil

       ;; This is the default, and seems to handle the standard cmd key
       ;; bindings, so apple cmd+c runs super+c in emacs, etc. I don't use them
       ;; much, but they might be useful sometimes.
       ns-right-command-modifier 'super

       ;; Instead of the cmd bindings (that I don't use much), use the left
       ;; cmd key for Meta bindings. This is easier to reach than the default Meta
       ;; key (which is alt).
       ns-command-modifier 'meta))
#+END_SRC
* General utils

** Odd functions
#+BEGIN_SRC emacs-lisp
  (defun md/strip-whitespace-and-save ()
    (interactive)
    (delete-trailing-whitespace)
    (save-buffer))

  (defun md/fontify-buffer ()
    (interactive)
    (font-lock-fontify-buffer)
    (message "Fontified buffer"))

  (defun md/file-info ()
    (interactive)
    (message
     "%s | %s lines | %3d%% | %s"
             (buffer-file-name)
             (count-lines (point-min) (point-max))
             (/ (window-end) 0.01 (point-max))
             major-mode)) 

  (defun md/mode-info ()
    (interactive)
    (message 
     (format
      "%s"
      (with-temp-buffer
        (let (mm result)
          (dolist (mm (sort minor-mode-list 'string<) result)
            (insert (format "%s\n" mm))
            (setq result (buffer-substring (point-min) (point-max))))
          result)))))

#+END_SRC

** Leader
I was using evil-leader, but think I can get the functionality I care about just
by using a keymap:

#+BEGIN_SRC emacs-lisp
(defvar md/leader-map (make-sparse-keymap))
#+END_SRC

** Bindings
I seem to use =describe-face= a lot:
#+BEGIN_SRC emacs-lisp
(bind-key "x" 'describe-face help-map)
(bind-key "C-k" 'describe-personal-keybindings help-map)
#+END_SRC
* Evil
** Base evil
#+BEGIN_SRC emacs-lisp
(use-package
 evil
 :config
 (progn
   (defun md/normal-state-and-save ()
     (interactive)
     (evil-normal-state)
     (save-buffer))

   (defun md/insert-blank-line-before ()
     (interactive)
     (save-excursion
       (end-of-line)
       (open-line 1)
       (save-buffer)))

   (defun md/insert-blank-line-after ()
     (interactive)
     (save-excursion
       (evil-previous-visual-line)
       (end-of-line)
       (open-line 1)
       (save-buffer)))

   ;; Can't work out how to properly define map bindings using ":bind"
   (bind-key "<SPC>" md/leader-map evil-normal-state-map)
   (bind-key "<SPC>" md/leader-map evil-visual-state-map)

   (bind-key "h" help-map md/leader-map)  ; I prefer <leader>h to C-h

   (evil-mode 1))

 :bind (;; Like my vimrc, remap  ; to : and , to ;
        :map evil-motion-state-map
        (";" . evil-ex)
        ("," . evil-repeat-find-char)

        ;; Use H/L instead of ^/$
        :map evil-normal-state-map
        ("H" . move-beginning-of-line)
        ("L" . move-end-of-line)
        :map evil-visual-state-map
        ("H" . move-beginning-of-line)
        ("L" . move-end-of-line)

        ;; The equivalent of gj/gk
        :map evil-normal-state-map
        ("j" . evil-next-visual-line)
        ("k" . evil-previous-visual-line)

        ;; Leader bindings
        :map md/leader-map
        ("w" . save-buffer)
        ("W" . md/strip-whitespace-and-save)

        ;; TODO behave like vim - ie. comment the line or the selection
        ("cc" . comment-or-uncomment-region)
        ("k" . kill-buffer)

        ("ef" . eval-defun)
        ("ee" . eval-last-sexp)  ; Bound to e because I'm used to C-x e
        ("eb" . eval-buffer)
        ("er" . eval-region)
        ("ex" . md/fontify-buffer)  ; It's sort-of an eval

        ("lw" . toggle-truncate-lines)

        ;; Same as vim - insert and save
        ("o" . md/insert-blank-line-before)
        ("O" . md/insert-blank-line-after)))

(require 'evil)
#+END_SRC

** Evil surround
#+BEGIN_SRC emacs-lisp
(use-package
 evil-surround
 :config
 (progn
   (global-evil-surround-mode 1)))
#+END_SRC

** Easymotion
#+BEGIN_SRC emacs-lisp
(use-package
 ace-jump-mode

 :config
 (progn
   (setq
    ace-jump-mode-move-keys '(?f ?j ?d ?k ?s ?l ?a ?\; ?g ?h ?r ?u ?e ?i ?w ?o ?t ?y ?b ?v ?n ?c ?m ?x)
    ace-jump-mode-scope 'window  ; If scope is wider than window performance drops a lot
    ace-jump-word-mode-use-query-char))

 :bind (:map evil-normal-state-map
             ("f" . nil)
             ("f j" . evil-ace-jump-line-mode)
             ("f k" . evil-ace-jump-line-mode)
             ("f w" . evil-ace-jump-word-mode)
             ("f b" . evil-ace-jump-word-mode)
             ("f f" . evil-ace-jump-char-mode)
             ("f F" . evil-ace-jump-char-mode)
             ("f t" . evil-ace-jump-char-mode)
             ("f T" . evil-ace-jump-char-mode)))
#+END_SRC

* Key Chord
I can't just set my insert mode "jj" and "jk" bindings in the insert-mode-map,
because if I do that then "j" gets assigned as a prefix key, and I can't
actually use it to insert anything in insert mode.

#+BEGIN_SRC emacs-lisp
  (use-package
    key-chord
    :config
    (progn
      (setq key-chord-two-keys-delay 0.4)

      (key-chord-define evil-insert-state-map "jj" 'md/normal-state-and-save)
      (key-chord-define evil-insert-state-map "jk" 'evil-normal-state)
      (key-chord-mode 1)))
#+END_SRC

* Highlight keywords in comments

#+BEGIN_SRC emacs-lisp
(use-package
 fic-mode
 :config
 (progn
   ;; NOTE: fic-mode doesn't seem to fontify the buffer, so words don't appear
   ;; highlighted unless either something else fontifies the buffer, or we do it
   ;; manually. Would like to improve this.
   ;;
   ;; FIX: fic-mode doesn't seem to identify words on the same line as my cursor
   ;; when I change theme and then fontify the buffer. All other lines seem fine.

   (add-hook 'prog-mode-hook 'fic-mode)

   (setq fic-highlighted-words
         '("TODO" "FIX" "FIXME" "BUG" "WARN" "WARNING" "HACK" "NOTE" "ERROR" "MATT"))

   ;; By default this includes font-lock-string-face, but I don't want strings to
   ;; have these words formatted.
   (setq fic-activated-faces '(font-lock-doc-face font-lock-comment-face))))
#+END_SRC

I can use this with grep/ag to quickly find the todo comments:
#+BEGIN_SRC emacs-lisp
  (defun md/insert-todo-regexp ()
    (interactive)
    (insert "TODO|FIX|FIXME|BUG|WARN|HACK|ERROR"))
#+END_SRC

* Helm
** Base helm
- [ ] NOTE - describe-function and describe-variable don't use helm until helm
  has been configured. Work out how to load helm when they're called.

#+BEGIN_SRC emacs-lisp
  (use-package
    helm
    :config
    (progn
      (helm-mode 1)
      (helm-autoresize-mode 0))
    :bind (([remap find-file] . helm-find-files)
           ([remap occur] . helm-occur)
           ([remap dabbrev-expand] . helm-dabbrev)
           ([remap list-buffers] . helm-buffers-list)
           ("M-x" . helm-M-x)
           ("C-x b" . helm-buffers-list)
           ("C-x p" . helm-mini)

           :map helm-map
           ;; This lets me quickly ag/grep for "todo" comments using the same
           ;; ag/grep functions that I usually do.
           ("C-c C-t" . md/insert-todo-regexp)
           ;;("<tab>" . helm-execute-persistent-action)
           ;;("C-z" . helm-select-action)

           :map lisp-interaction-mode-map
           ([remap completion-at-point] . helm-lisp-completion)

           :map emacs-lisp-mode-map
           ([remap completion-at-point] . helm-lisp-completion)

           :map md/leader-map
           ("b" . helm-buffers-list)
           ("f" . helm-find-files)
           ("x" . helm-M-x)
           ("p" . helm-mini)

           :map help-map
           ("X" . helm-colors)))

#+END_SRC

** Addons
#+BEGIN_SRC emacs-lisp
  (use-package helm-ag
    :config
    (defun md/ag ()
      "Run helm-do-ag on the default-directory"
      (interactive)
      (helm-do-ag default-directory))
    :bind (:map md/leader-map
                ("ag" . md/ag)))
#+END_SRC

* help-fns+
This package provides ~describe-keymap~ to M-k in the help-map, which is
handy. It does some other things too (TODO - read docs).

#+BEGIN_SRC emacs-lisp
(use-package help-fns+) 
(require 'help-fns+)
#+END_SRC

* Help mode
I prefer to use vi keys to navigate help-mode:

#+BEGIN_SRC emacs-lisp
  (evil-set-initial-state 'help-mode 'normal)
  (evil-define-key 'normal help-mode-map
    "q" 'quit-window
    (kbd "C-i") 'help-go-forward
    (kbd "C-o") 'help-go-back
    (kbd "<RET>") 'help-follow-symbol)
#+END_SRC

* Parentheses
Basic paren matching is built in. I preferred these settings at one point,
although I don't remember exactly what the difference is:

#+BEGIN_SRC emacs-lisp
    (use-package
     paren
     :config
     (progn
       (setq show-paren-style 'parenthesis
             blink-matching-paren nil
             blink-matching-paren-on-screen nil)
       (add-hook 'prog-mode-hook 'show-paren-mode)))
#+END_SRC

* Elscreen

Elscreen provides "tabs" that let me sort of arrange windows how I did it in
vim. They're not ideal though, because the tabs either appear in several places
on the screen, or nowhere.

#+BEGIN_SRC emacs-lisp
  (use-package
   elscreen
   :config
   (progn
     (defun md/elscreen-hide-tabs ()
       (interactive)
       ;; This is how elscreen hides tabs in (elscreen-toggle-display-tab)
       (setq elscreen-display-tab nil)
       (elscreen-notify-screen-modification 'force))

     (md/elscreen-hide-tabs)))
#+END_SRC

* Splitscreen
#+BEGIN_SRC emacs-lisp
(setq md/splitscreen-path (concat (md/get-dotfiles-path) "/splitscreen/"))

(use-package
 splitscreen
 :load-path md/splitscreen-path
 :config
 (progn
   (splitscreen-mode)))
#+END_SRC
* Org
#+BEGIN_SRC emacs-lisp
  (use-package
   org
   :config
   (progn

     (defun md/org-timestamp-time-inactive-no-confirm ()
       (interactive)
       (org-insert-time-stamp (current-time) t t))

     (defun md/org-timestamp-date-inactive-no-confirm ()
       (interactive)
       (org-insert-time-stamp (current-time) nil t))

     (defun md/org-insert-link-from-paste ()
       (interactive)
       (org-insert-link nil
                        (with-temp-buffer
                          (evil-paste-after nil)
                          (delete-trailing-whitespace)
                          (buffer-string))))

     (defun md/org-hook ()
       ;; Change tab widths to fit headline indents
       (setq tab-width 2
             evil-shift-width 2)

       ;; Disable in-buffer line numbers and the colour column, as both decrease
       ;; org-mode / outline performance significantly on large files.
       (linum-mode 0)
       (fci-mode 0)

       ;; Also disable the row and column numbers in the modeline. Seems you have to set
       ;; these manually to make them buffer-local, unlike the above functions - TODO
       ;; is this a bad thing?
       (setq-local line-number-mode nil)
       (setq-local column-number-mode nil)

       ;; Also don't highlight the current line. For some reason this rquires making
       ;; global-hl-line-mode buffer-local.
       (make-variable-buffer-local 'global-hl-line-mode)
       (setq-local global-hl-line-mode nil))

     (define-minor-mode md/evil-org-mode
       "Buffer local minor mode for evil-org"
       :init-value nil
       :lighter " EvilOrg"
       :keymap (make-sparse-keymap) ; defines md/evil-org-mode-map
       :group 'md/evil-org)

     ;; NOTE - I don't think the use-package ":bind" arg allows defining evil keys
     ;; for a specific evil-mode/map combination.

     ;; Normal state shortcuts
     (evil-define-key 'normal md/evil-org-mode-map
       "gk" 'outline-previous-visible-heading
       "gj" 'outline-next-visible-heading
       "H" 'org-beginning-of-line
       "L" 'org-end-of-line
       "$" 'org-end-of-line
       "^" 'org-beginning-of-line
       "-" 'org-cycle-list-bullet
       (kbd "RET") 'org-cycle
       (kbd "TAB") 'org-cycle)

     ;; Normal & insert state shortcuts.
     (mapc (lambda (state)
             (evil-define-key state md/evil-org-mode-map
               (kbd "M-l") 'org-metaright
               (kbd "M-h") 'org-metaleft
               (kbd "M-k") 'org-metaup
               (kbd "M-j") 'org-metadown
               (kbd "M-L") 'org-shiftmetaright
               (kbd "M-H") 'org-shiftmetaleft
               (kbd "M-K") 'org-shiftmetaup
               (kbd "M-J") 'org-shiftmetadown
               ))
           '(normal insert))

     ;; I don't like the default org-agenda bindings - there are far more
     ;; bindings/features than I should have to think about, and I usually try to
     ;; navigate using evil bindings (and eg. accidentally hit "j" and bring up
     ;; the calendar etc).
     ;;
     ;; Instead, open org-agenda in evil-normal-mode, with a couple of the useful
     ;; bindings copied directly from emacs-mode.
     (define-minor-mode md/evil-org-agenda-mode
       "Buffer local minor mode for evil-org-agenda"
       :init-value nil
       :lighter " EvilOrgAgenda"
       :keymap (make-sparse-keymap) ; defines md/evil-org-agenda-mode-map
       :group 'md/evil-org-agenda)

     (evil-set-initial-state 'org-agenda-mode 'normal)

     (evil-define-key 'normal md/evil-org-agenda-mode-map
       ;; j / k
       (kbd "j") 'org-agenda-next-line
       (kbd "n") 'org-agenda-next-line
       (kbd "C-n") 'org-agenda-next-line
       (kbd "k") 'org-agenda-previous-line
       (kbd "p") 'org-agenda-previous-line
       (kbd "C-p") 'org-agenda-previous-line

       (kbd "q") 'org-agenda-quit
       (kbd "r") 'org-agenda-redo  ; Recalculate the agenda
       (kbd "v") 'org-agenda-view-mode-dispatch  ; Alter the view
       (kbd "|") 'org-agenda-filter-remove-all  ; Remove existing filters
       (kbd "=") 'org-agenda-filter-by-regexp  ; Search
       (kbd "/") 'org-agenda-filter-by-tag  ; Tag filter
       (kbd "^") 'org-agenda-filter-by-top-headline  ; Show other items with same
                                          ; headline as current
       (kbd "A") 'org-agenda-append-agenda)  ; Add another agenda

     (add-hook 'org-mode-hook 'md/org-hook)
     (add-hook 'org-mode-hook 'md/evil-org-mode)
     (add-hook 'org-agenda-mode-hook 'md/evil-org-agenda-mode)

     (setq org-agenda-restore-windows-after-quit t

           ;; Add timestamp when set task as closed
           org-log-done 'time

           ;; Fontify inline code
           org-src-fontify-natively t

           ;; When editing code, I don't want to open another window. This
           ;; just makes the screen tidier.
           org-src-window-setup 'current-window

           ;; tab / indentation is the main reason I would use C-' so prevent it if possible
           org-src-tab-acts-natively t

           ;; Colour the whole headline
           org-level-color-stars-only nil

           ;; Try to prevent accidentally editing invisible lines
           org-catch-invisible-edits 'show-and-error

           org-adapt-indentation nil

           org-clock-out-remove-zero-time-clocks t

           ;; If press M-RET I want a new line, not to split the line
           org-M-RET-may-split-line nil

           ;; Default to using my CSS theme for html exports
           org-html-head-extra "
          <link id='generic-css-dark' rel='stylesheet' type='text/css'
                href='https://mattduck.github.io/generic-css/css/generic-dark.css'>
          <link id='generic-css-light' rel='stylesheet' type='text/css'
                href='https://mattduck.github.io/generic-css/css/generic-light.css'>
          <script type='text/javascript'src='https://mattduck.github.io/generic-css/js/generic-css.js'></script>"

           org-export-headline-levels 6
           org-export-with-section-numbers 4))
   :bind (:map global-map
         ("C-c a" . org-agenda)

         :map org-mode-map
         ("C-c d" . md/org-timestamp-date-inactive-no-confirm)
         ("C-c t" . md/org-timestamp-time-inactive-no-confirm)
         ("C-c l" . md/org-insert-link-from-paste)))

#+END_SRC
* Modeline
** General modeline
#+BEGIN_SRC emacs-lisp
(line-number-mode 1)
(column-number-mode 1)
#+END_SRC

** Powerline
#+BEGIN_SRC emacs-lisp
(use-package
 powerline
 :config
 (progn
   (defun md/powerline-setup ()
     (interactive)
     (require 'flycheck)
     (setq-default mode-line-format
                   '("%e"
                     (:eval
                      (let* ((active (powerline-selected-window-active))
                             (mode-line (if active 'mode-line 'mode-line-inactive))
                             (face1 (if active 'powerline-active1 'powerline-inactive1))
                             (face2 (if active 'powerline-active2 'powerline-inactive2))
                             (separator-left (intern (format "powerline-%s-%s"
                                                             (powerline-current-separator)
                                                             (car powerline-default-separator-dir))))
                             (separator-right (intern (format "powerline-%s-%s"
                                                              (powerline-current-separator)
                                                              (cdr powerline-default-separator-dir))))

                             (lhs (list (powerline-raw evil-mode-line-tag face2 'l)
                                        (funcall separator-left face2 face1)
                                        (powerline-raw (format "*%s* " (powerline-major-mode)) face1 'l)
                                        (funcall separator-left face1 mode-line)
                                        (if (and (boundp 'projectile-mode) projectile-mode)
                                            (powerline-raw (concat (projectile-project-name) "::%b") 'l)
                                          (powerline-raw "%b" mode-line 'l))

                                        (when (buffer-modified-p)
                                          (powerline-raw "+" mode-line 'l))
                                        (when buffer-read-only
                                          (powerline-raw "[RO]" mode-line 'l))
                                        (when (buffer-narrowed-p)
                                          (powerline-raw "  Narrow" mode-line 'l))
                                        (when (and active (fboundp 'org-clocking-p) (org-clocking-p))
                                          (powerline-raw
                                           (propertize
                                            (format "  %s "
                                                    (if (> (length org-mode-line-string) 50)
                                                        (format "%s..." (string-trim (substring org-mode-line-string 0 50)))
                                                      org-mode-line-string))
                                            'face nil)
                                           mode-line 'l))))

                             (rhs (list (funcall separator-right mode-line face1)
                                        (powerline-vc face1 'r)
                                        (when (or line-number-mode column-number-mode)
                                          (cond ((and line-number-mode
                                                      column-number-mode)
                                                 (powerline-raw "%5l:%2c" face2 'r))
                                                (line-number-mode
                                                 (powerline-raw "%5l" face2 'r))
                                                (column-number-mode
                                                 (powerline-raw ":%2c" face2 'r))))


                                        ;; TODO: change colour when err/warn, and
                                        ;; list line of first error
                                        ;; (when flycheck-mode
                                        ;;   (powerline-raw (format "%6s" (flycheck-mode-line-status-text)) 'error 'r))
                                        (when (and active flycheck-mode (flycheck-has-current-errors-p))
                                          (powerline-raw
                                           (format " [line:%s (%s)] "
                                                   ;; Line of first err
                                                   (save-excursion
                                                     (flycheck-first-error)
                                                     (+ 1 (count-lines (point-min) (point))))
                                                   ;; Total lines
                                                   (length flycheck-current-errors))

                                           ;; Face
                                           (cond ((flycheck-has-current-errors-p 'error)
                                                  'md/modeline-flycheck-error)
                                                 ((flycheck-has-current-errors-p 'warning)
                                                  'md/modeline-flycheck-warning))
                                           'r))



                                        ))
                             )
                        (concat (powerline-render lhs)
                                (powerline-fill mode-line (powerline-width rhs))
                                (powerline-render rhs)))))))

   (defun md/powerline-reset ()
     (interactive)
     (setq mode-line-format (md/powerline-setup))
     (solarized-load-theme))

   (md/powerline-setup)))

(require 'powerline)
#+END_SRC
* Syntax checking
#+BEGIN_SRC emacs-lisp
(use-package
 flycheck
 :config
 (progn
   (defface md/modeline-flycheck-error '((t (:inherit 'error))) "")
   (defface md/modeline-flycheck-warning '((t (:inherit 'warning))) "")

   (setq flycheck-flake8rc ".config/flake8"
         flycheck-highlighting-mode 'symbols

         ;; defaults to 0.9, which is too slow
         flycheck-display-errors-delay 0.1

         ;; There's a short delay when flycheck runs, which causes the modeline to change
         ;; its format (or in my custom powerline stuff, to disappear briefly). It's
         ;; super annoying if this happens at random points during editing, so change it
         ;; to only happen on save (and when enabling the mode). This is quite similar to how
         ;; I had it setup in vim.
         flycheck-check-syntax-automatically '(save mode-enabled)

         flycheck-mode-line-prefix nil)

   (add-hook 'prog-mode-hook 'flycheck-mode))
 :bind (:map md/leader-map
        ;; S prefix, ie. "syntax"
        ("s <RET>" . flycheck-mode)
        ("sl" . flycheck-list-errors)
        ("sn" . flycheck-next-error)
        ("sj" . flycheck-next-error)
        ("sp" . flycheck-previous-error)
        ("sk" . flycheck-previous-error)))

#+END_SRC
* Projectile
** Base projectile
#+BEGIN_SRC emacs-lisp
(use-package
 projectile
 :config
 (progn
   (setq projectile-file-exists-local-cache-expire (* 10 60)
         projectile-enable-caching t)
   (projectile-global-mode))
 :bind (:map md/leader-map
       ("jk" . projectile-kill-buffers)))
#+END_SRC

** Helm
#+BEGIN_SRC emacs-lisp
  (use-package
   helm-projectile
   :bind (:map md/leader-map
         ("jj" . helm-projectile-switch-project)
         ("jag" . helm-projectile-ag)
         ("jb" . helm-projectile-switch-to-buffer)

         ;; TODO - proper binding for invalidating cache
         ("jf" . helm-projectile-find-file)))
#+END_SRC

* Git
** git-gutter
#+BEGIN_SRC emacs-lisp
  (use-package
   git-gutter
   :init
   (progn
     (add-hook 'prog-mode-hook 'git-gutter-mode))
   :config
   (progn
     (setq git-gutter:ask-p nil  ; Don't ask for confirmation of gadd
           git-gutter:modified-sign "~"
           git-gutter:added-sign "+"
           git-gutter:deleted-sign "-"

           ;; Without this, there's no space between the git-gutter column and the code.
           git-gutter:separator-sign " "))
   :bind (:map md/leader-map
         ("g <RET>" . git-gutter-mode)
         ("gk" . git-gutter:previous-hunk)
         ("gp" . git-gutter:previous-hunk)
         ("gj" . git-gutter:next-hunk)
         ("gn" . git-gutter:next-hunk)
         ("gadd" . git-gutter:stage-hunk)
         ("grev" . git-gutter:revert-hunk)))

#+END_SRC

** magit
#+BEGIN_SRC emacs-lisp
  (use-package
   magit
   :config
   (progn
     (evil-set-initial-state 'magit-blame-mode 'normal)
     (evil-set-initial-state 'magit-revision-mode 'normal)

     ;; I don't know why, but by default I can't get magit-blame to adhere to my
     ;; normal-mode map below, even though Evil says I'm in normal mode. Explicitly
     ;; calling evil-normal-state fixes it.
     (add-hook 'magit-blame-mode-hook 'evil-normal-state)
     (evil-define-key 'normal magit-blame-mode-map
       (kbd "<RET>") 'magit-show-commit
       "q" 'magit-blame-quit
       "gj" 'magit-blame-next-chunk
       "gn" 'magit-blame-next-chunk
       "gk" 'magit-blame-previous-chunk
       "gp" 'magit-blame-previous-chunk)

     (add-hook 'magit-revision-mode-hook 'evil-normal-state)
     (evil-define-key 'normal magit-revision-mode-map
       (kbd "<RET>") 'magit-diff-visit-file
       "q" 'magit-mode-bury-buffer))  ;; This quits

   :bind (:map md/leader-map
         ("gmag" . magit-dispatch-popup)
         ("gblame" . magit-blame)
         ("gdiff" . magit-ediff-popup)))

#+END_SRC

* Web mode
This makes working with HTML/CSS/JS files much nicer. TODO - read documentation
/ configure.

#+BEGIN_SRC emacs-lisp
(use-package
 web-mode)

#+END_SRC

* Ediff
#+BEGIN_SRC emacs-lisp
(use-package
 ediff
 :config
 (progn
   ;; TODO - I want ediff to have evil-like bindings
   (setq ediff-split-window-function 'split-window-horizontally)))

#+END_SRC
* Solarized

#+BEGIN_SRC emacs-lisp
  (use-package
   color-theme-solarized
   :ensure nil
   :load-path "non-elpa/color-theme-solarized"
   :config
   (progn
     (add-to-list 'custom-theme-load-path "non-elpa/color-theme-solarized")

     ;; Necessary on v24.4 to display accurate Solarized colors, due to Emacs bug
     ;; #8402. v24.3 didn't set ns-use-sgrb-colorspace.
     (setq ns-use-srgb-colorspace nil
           solarized-broken-srgb t)

     ;; See heading on terminal colour fixes near top of file
     (when (not (display-graphic-p))
       (setq solarized-bold nil))

     (load-theme 'solarized t)  ; Defaults to light
     (solarized-enable-theme 'dark))

   :bind (:map md/leader-map
          ("sol" . solarized-toggle-theme-mode)
          ("chl" . solarized-toggle-comment-visibility)))
(require 'color-theme-solarized)
#+END_SRC

* Dotfiles

Equivalent of my "ve" binding that would edit my vimrc:

#+BEGIN_SRC emacs-lisp
  (defun md/dotfiles-edit ()
    (interactive)
    (find-file (concat (md/get-dotfiles-path) "/emacs.d.symlink/init.org")))

  (bind-key "ve" 'md/dotfiles-edit md/leader-map)
#+END_SRC

* Teardown

Reset the gc threshold to the default:

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 800000)
#+END_SRC

* TODO
- [ ] tab key not inserting tabs in evil?
  - it aligns but doesn't insert tab, not sure if this is behaviour i want. It
    runs indent-for-tab-command. Try it for a while.
- [ ] savehist-mode.
- [ ] indents.
- [ ] read electric-indent docs.
- [ ] does electric-indent need different configuration in python? I used to
  have something for this.
- [ ] undo tree?
- [ ] info / other help modes - use vi keys to navigate?
- [ ] how to preserve binding in map?
  - Eg. I want to use normal mode for some magit modes, but I generally want to retain
    the behaviour of RET. This is true for help modes too.
- [ ] jumping to definitions
- [ ] finding uses of functions
- [ ] ediff / git diff
- [ ] git checkout would be nice
- [ ] colour emacs state in modeline
- [ ] checkout avy - improvement to acejump?
- [ ] md/file-info binding
- [ ] debugger
- [ ] folding
- [ ] autocomplete
- [ ] spellcheck?
- [ ] checkout slime
- [ ] unfill paragraph
- [ ] jumping forward back to markers including between files
- [ ] stop littering # backup files
